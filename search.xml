<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>中断和异常</title>
      <link href="/2023/12/11/Five/"/>
      <url>/2023/12/11/Five/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;对《操作系统》的知识梳理  五</p><span id="more"></span><h2 id="零、总览"><a href="#零、总览" class="headerlink" title="零、总览"></a>零、总览</h2><p><img src="/2023/12/11/Five/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8.jpg"></p><h2 id="一、中断的作用"><a href="#一、中断的作用" class="headerlink" title="一、中断的作用"></a>一、中断的作用</h2><p>&emsp;&emsp;CPU上会运行两种程序，一种是<strong>操作系统内核程序</strong>，一种是<strong>应用程序</strong>，在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序。</p><p>&emsp;&emsp;总之，一个应用程序一旦上CPU运行之后，它就会一直运行下去，除非发生了中断。一旦发生了中断，就会让CPU立即停止运行应用程序，转而执行内核程序。<strong>“中断”是让操作系统内核夺回CPU使用权的唯一途径</strong>，会使CPU由用户态变为内核态 。</p><h2 id="二、中断的类型"><a href="#二、中断的类型" class="headerlink" title="二、中断的类型"></a>二、中断的类型</h2><h3 id="emsp-1-内中断"><a href="#emsp-1-内中断" class="headerlink" title="&emsp;1.内中断"></a>&emsp;1.内中断</h3><p>&emsp;&emsp;与当前执行的指令有关，中断信号来源于CPU内部。</p><p>&emsp;&emsp;例如：试图在用户态下执行特权指令、执行除法指令时发现除数为0、有时候应用程序想请求操作系统内核的服务，此时会执行<strong>一条特殊的指令——陷入指令（非特权指令）</strong>，该指令会引发一个内部中断信号，系统调用就是使用这种方式完成。</p><h3 id="emsp-2-外中断"><a href="#emsp-2-外中断" class="headerlink" title="&emsp;2.外中断"></a>&emsp;2.外中断</h3><p>&emsp;&emsp;与当前执行的指令无关，中断信号来源于CPU外部。</p><p>&emsp;&emsp;例如：时钟中断——由时钟部件发来的中断信号（例如每50 ms给CPU发送一个中断信号)、I&#x2F;O中断——由输入&#x2F;输出设备发来的中断信号（CPU每一条指令执行结束都会例行检查是否有外中断信号）</p><h2 id="三、中断的分类"><a href="#三、中断的分类" class="headerlink" title="三、中断的分类"></a>三、中断的分类</h2><img src="中断的分类.jpg" style="zoom:67%;" /><p>&emsp;&emsp;陷阱、陷入：由陷入指令引发，是应用程序故意引发的。</p><p>&emsp;&emsp;故障：由错误条件引起，可能被内核程序修复，内核程序修复故障后会把CPU使用权还给应用程序，让它继续执行下去，如：缺页故障。</p><p>&emsp;&emsp;终止：由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。如：整数除0、非法使用特权指令等。</p><h2 id="四、中断机制的基本原理"><a href="#四、中断机制的基本原理" class="headerlink" title="四、中断机制的基本原理"></a>四、中断机制的基本原理</h2><p>&emsp;&emsp;<strong>不同的中断信号，需要用不同的中断处理程序来处理。</strong>当CPU检测到中断信号后，会根据中断信号的类型去查询“<strong>中断向量表</strong>”，以此来找到相应的中断处理程序在内存中存放的位置。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p><img src="/2023/12/11/Five/%E6%80%BB%E7%BB%93.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统的运行机制</title>
      <link href="/2023/12/11/Four/"/>
      <url>/2023/12/11/Four/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;对《操作系统》的知识梳理  四</p><span id="more"></span><h2 id="零、总览"><a href="#零、总览" class="headerlink" title="零、总览"></a>零、总览</h2><img src="操作系统的运行机制.jpg" style="zoom: 67%;" /><p><strong>预备知识：程序是如何运行的？</strong></p><p>&emsp;&emsp;C语言代码经过编译器“翻译”成机器指令（二进制码），CPU运行C语言代码的过程，就是CPU执行被编译器编译后的一条一条的机器指令的过程。</p><p>&emsp;&emsp;本节中的指令，指的是二进制机器指令。</p><h2 id="一、内核程序与应用程序"><a href="#一、内核程序与应用程序" class="headerlink" title="一、内核程序与应用程序"></a>一、内核程序与应用程序</h2><p>&emsp;&emsp;一般来说，普通程序员写的程序就是“<strong>应用程序</strong>”，像微软、苹果有一帮人负责实现操作系统，他们写的就是“<strong>内核程序</strong>”，由很多内核程序组成了“<strong>操作系统内核</strong>”，或简称“**内核(Kernel)**”。</p><p>&emsp;&emsp;<strong>内核</strong>是操作系统最重要最核心的部分，也是<strong>最接近硬件的部分</strong>。甚至可以说，一个操作系统只有有内核就够了（<strong>操作系统的功能未必都在内核中</strong>，如图形化用户界面GUI）。</p><h2 id="二、特权指令与非特权指令"><a href="#二、特权指令与非特权指令" class="headerlink" title="二、特权指令与非特权指令"></a>二、特权指令与非特权指令</h2><p>&emsp;&emsp;在CPU设计和生产的时候就划分了特权指令和非特权指令，因此，CPU在执行一条指令前就能判断出其类型。</p><p>&emsp;&emsp;操作系统内核作为“管理者”，有时候会让CPU执行一些“<strong>特权指令</strong>”，如，内存清零指令。这些指令影响重大，<strong>只允许</strong>“管理者”——即<strong>操作系统内核来使用</strong>。</p><p>&emsp;&emsp;简单地说，如果这段程序是普通的<strong>应用程序</strong>的话，它<strong>只能使用非特权指令</strong>，如：加法指令、减法指令等。</p><h2 id="三、内核态和用户态"><a href="#三、内核态和用户态" class="headerlink" title="三、内核态和用户态"></a>三、内核态和用户态</h2><p>&emsp;&emsp;CPU有两种状态，<strong>内核态</strong>和<strong>用户态</strong>。</p><p>&emsp;&emsp;处于<strong>内核态时</strong>，说明此时<strong>正在运行的是内核程序</strong>，此时<strong>可以执行特权指令</strong>；处于<strong>用户态时</strong>，说明此时<strong>正在运行的是应用程序</strong>，此时<strong>只能执行非特权指令</strong>。</p><p>&emsp;&emsp;在CPU中有一个寄存器叫<strong>程序状态字寄存器（PSW）</strong>，其中有个二进制位，1表示内核态，0表示用户态。</p><p>&emsp;&emsp;用户态 &#x3D; <strong>目态</strong>，内核态 &#x3D; 核心态 &#x3D; <strong>管态</strong>。</p><h2 id="四、内核态、用户态的切换"><a href="#四、内核态、用户态的切换" class="headerlink" title="四、内核态、用户态的切换"></a>四、内核态、用户态的切换</h2><p>以一个例子说明：</p><p>&emsp;&emsp;刚开机时，CPU为内核态，操作系统内核程序先上CPU运行。开机完成后，用户可以启动某个应用程序。操作系统内核程序在合适的时候主动让出CPU，<strong>操作系统内核在让出CPU之前，会用一条特权指令把PSW的标志位设置为用户态</strong>。应用程序在CPU上运行，运行在用户态。</p><p>&emsp;&emsp;如果在应用程序中，有一条特权指令。CPU发现接下来要执行的这条指令是特权指令，但是自己又处于用户态时，这个非法事件会引发一个中断信号。<strong>CPU检测到中断信号后</strong>，会立即<strong>变为核心态</strong>，停止执行当前的应用程序，转而运行处理中断信号的内核程序。中断使操作系统再次夺回CPU的控制权，操作系统会对引发中断的事件进行处理，处理完后再把CPU使用权交给别的应用程序。</p><p>综上：</p><p>&emsp;&emsp;<strong>内核态→用户态</strong>：执行一条<strong>特权指令——修改PSW的标志位为“用户态”</strong>，这个动作意味着操作系统主动让出CPU的使用权。</p><p>&emsp;&emsp;<strong>用户态→内核态</strong>：由“<strong>中断</strong>“引发，<strong>硬件自动完成变态过程</strong>，触发中断信号意味着操作系统将强行夺回CPU的使用权。（除了非法使用特权指令外，但凡需要操作系统介入的地方，都会触发中断信号）</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p><img src="/2023/12/11/Four/%E6%80%BB%E7%BB%93.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统的发展与分类</title>
      <link href="/2023/12/10/Three/"/>
      <url>/2023/12/10/Three/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;对《操作系统》的知识梳理  三</p><span id="more"></span><h2 id="零、总览"><a href="#零、总览" class="headerlink" title="零、总览"></a>零、总览</h2><img src="OS的发展与分类.jpg" style="zoom:67%;" /><h2 id="一、手工操作阶段"><a href="#一、手工操作阶段" class="headerlink" title="一、手工操作阶段"></a>一、手工操作阶段</h2><p>&emsp;&emsp;过程：用户把程序写在纸带上(其实就是在纸带上打孔)，然后输入到计算机中，计算机随后会处理这个程序，把输出结果又放在纸带中(其实还是打孔)，展示给用户看。</p><img src="手工操作阶段.jpg" style="zoom:67%;" /><p>&emsp;&emsp;由于用户在纸带上编写程序的速度很慢，纸带输入输出的速度也很慢，而计算机的处理速度快，所以系统资源的利用率极低。<br>&emsp;&emsp;<strong>主要缺点：用户独占全机，人机速度矛盾导致系统资源利用率极低。</strong></p><img src="手工操作阶段时序图.jpg" style="zoom:67%;" /><h2 id="二、批处理阶段"><a href="#二、批处理阶段" class="headerlink" title="二、批处理阶段"></a>二、批处理阶段</h2><h3 id="1-单道批处理系统"><a href="#1-单道批处理系统" class="headerlink" title="1.单道批处理系统"></a>1.单道批处理系统</h3><p>&emsp;&emsp;单道批处理系统引入了<strong>脱机输入&#x2F;输出技术(用磁带完成)<strong>，但是每次只能往内存中输入一道程序，</strong>监督程序</strong>(这是操作系统的雏形)负责控制程序的输入输出。<br>&emsp;&emsp;过程：多个用户把程序写在纸带上，然后通过外围机录入到磁带中，监督程序会控制程序的输入和输出，每次只允许计算机内存中存在一道用户程序。</p><img src="单道批处理阶段.jpg" style="zoom:67%;" /><p>&emsp;&emsp;主要优点: 缓和了一定程度的人机速度矛盾，资源利用率有所提升。<br>&emsp;&emsp;主要缺点: <strong>内存中仅能有一道用户程序运行</strong>，只有该程序运行结束后才能调入下一道程序，<strong>CPU有大量的空闲时间是在等待I&#x2F;O完成</strong>，资源利用率依然很低。</p><img src="单道批处理阶段时序图.jpg" style="zoom:67%;" /><h3 id="2-多道批处理系统（操作系统正式诞生）"><a href="#2-多道批处理系统（操作系统正式诞生）" class="headerlink" title="2.多道批处理系统（操作系统正式诞生）"></a>2.多道批处理系统（操作系统正式诞生）</h3><p>&emsp;&emsp;每次往计算机内存中输入多道程序，并引入了中断技术，由操作系统负责管理这些程序的并发运行。<br>&emsp;&emsp;过程：和单道批处理系统差不多，只不过是可以向计算机内存中调入多道程序，让他们在计算机内存中并发运行。<br>&emsp;&emsp;主要优点：多道程序<strong>并发</strong>运行，<strong>共享</strong>计算机资源，<strong>资源利用率大幅提升</strong>，CPU和其他资源保存”忙碌”状态的时间增长。<br>&emsp;&emsp;主要缺点：用户响应时间长，<strong>没有人机交互功能</strong>(用户提交自己的作业之后只能等待计算机处理完成，中间不能控制自己作业的执行)<br><img src="多道批处理阶段时序图.jpg"  /></p><h2 id="三、分时操作系统"><a href="#三、分时操作系统" class="headerlink" title="三、分时操作系统"></a>三、分时操作系统</h2><p>&emsp;&emsp;计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户&#x2F;作业服务</strong>，各个用户可通过终端与计算机进行交互。</p><p>&emsp;&emsp;主要优点：用户请求可以被及时响应，<strong>解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p><p>&emsp;&emsp;主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户&#x2F;作业都是完全公平的，循环地为每个用户&#x2F;作业服务一个时间片，不区分任务的紧急性。</p><h2 id="四、实时操作系统"><a href="#四、实时操作系统" class="headerlink" title="四、实时操作系统"></a>四、实时操作系统</h2><p>&emsp;&emsp;主要优点：能够优先响应一些紧急任务，某些紧急任务不需要时间片排队。</p><p>&emsp;&emsp;在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性和可靠性</strong>。</p><h3 id="1-硬实时系统"><a href="#1-硬实时系统" class="headerlink" title="1.硬实时系统"></a>1.硬实时系统</h3><p>&emsp;&emsp;指必须在绝对严格的规定时间内完成处理，如导弹控制系统、自动驾驶系统。</p><h3 id="2-软实时系统"><a href="#2-软实时系统" class="headerlink" title="2.软实时系统"></a>2.软实时系统</h3><p>&emsp;&emsp;指能接受偶尔违反时间规定，如12306火车订票系统。</p><h2 id="五、其他几种操作系统"><a href="#五、其他几种操作系统" class="headerlink" title="五、其他几种操作系统"></a>五、其他几种操作系统</h2><h3 id="1-网络操作系统："><a href="#1-网络操作系统：" class="headerlink" title="1.网络操作系统："></a>1.网络操作系统：</h3><p>&emsp;&emsp;是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，<strong>实现网络中各种资源的共享（如文件共享）和各种计算机之间的通信</strong>。（如：Windows NT就是一种典型的网络操作系统，网站服务器就可以使用）</p><h3 id="2-分布式操作系统："><a href="#2-分布式操作系统：" class="headerlink" title="2.分布式操作系统："></a>2.分布式操作系统：</h3><p>&emsp;&emsp;主要特点是<strong>分布性和并行性</strong>。系统中的各台计算机地位相同，<strong>任何工作都可以分布在这些计算机上，由它们并行、协同地完成这个任务</strong>。</p><h3 id="3-个人计算机操作系统："><a href="#3-个人计算机操作系统：" class="headerlink" title="3.个人计算机操作系统："></a>3.个人计算机操作系统：</h3><p>&emsp;&emsp;如Windows XP、MacOS，方便个人使用。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p><img src="/2023/12/10/Three/%E6%80%BB%E7%BB%93.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统的特征</title>
      <link href="/2023/12/10/Two/"/>
      <url>/2023/12/10/Two/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;对《操作系统》的知识梳理  二</p><span id="more"></span><h2 id="零、总览"><a href="#零、总览" class="headerlink" title="零、总览"></a>零、总览</h2><p>&emsp;&emsp;并发和共享是两个最基本的特征，二者互为存在条件。</p><img src="操作系统的特征.jpg" style="zoom:67%;" /><h2 id="一、并发"><a href="#一、并发" class="headerlink" title="一、并发"></a>一、并发</h2><p>&emsp;&emsp;<strong>并发</strong>：指两个或多个事件在同一时间间隔内发生。这些事件<strong>宏观上是同时发生</strong>的，但是<strong>微观上是交替发生</strong>的。</p><p>&emsp;&emsp;常考易混淆概念   并行：指两个或多个事件在同一时刻发生。</p><p>&emsp;&emsp;<strong>操作系统的并发性</strong>指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，微观上看是交替运行的。</p><p>&emsp;&emsp;操作系统就是伴随着“多道程序技术”而出现的。因此，<strong>操作系统和程序并发是一起诞生的</strong>。注意：<strong>单核CPU</strong>同一时刻只能执行<strong>一个程序</strong>，各个程序只能<strong>并发</strong>地执行；<strong>多核CPU</strong>同一时刻可以同时执行<strong>多个程序</strong>，多个程序可以<strong>并行</strong>地执行。比如，Intel的第八代 i-3 处理器就是<strong>4核CPU</strong>，意味着可以<strong>并行地执行4个程序</strong>。</p><p>&emsp;&emsp;比如，CPU中运行着微信、QQ、Word和Chrome，但是此时如果有第五个程序也想运行，比如说QQ音乐。我们就必须剥夺其中的某一个程序它对CPU的使用权，比如说我们把Word这个程序换下CPU，让QQ音乐这个程序上CPU运行，然后Word和QQ音乐交替使用CPU。总之，对于四核CPU来说，同一时刻只能同时执行四个程序，要有四个以上的程序“同时”运行的话，那么并发性依然是必不可少的，因此，<strong>并发性是操作系统的一个基本的特性</strong>。</p><h2 id="二、共享"><a href="#二、共享" class="headerlink" title="二、共享"></a>二、共享</h2><p>&emsp;&emsp;共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>&emsp;&emsp;资源共享有两种方式，一种是互斥共享方式，一种是同时共享方式。</p><h3 id="1-互斥共享方式"><a href="#1-互斥共享方式" class="headerlink" title="1.互斥共享方式"></a>1.互斥共享方式</h3><p>&emsp;&emsp;<strong>系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源</strong>。例如：使用QQ和微信视频，同一时间内摄像头只能分配给其中一个进程。</p><h3 id="2-同时共享方式"><a href="#2-同时共享方式" class="headerlink" title="2.同时共享方式"></a>2.同时共享方式</h3><p>&emsp;&emsp;<strong>系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问</strong>。所谓的同时，往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问（即分时共享）。例如：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。再比如，边玩游戏时边听歌，扬声器这个声音输出设备在宏观上是两边都在使用，微观上也是两边同时使用的。</p><h2 id="三、并发和共享的关系"><a href="#三、并发和共享的关系" class="headerlink" title="三、并发和共享的关系"></a>三、并发和共享的关系</h2><p>&emsp;&emsp;<strong>并发性</strong>指计算机系统中同时存在着多个运行着的程序。</p><p>&emsp;&emsp;<strong>共享性</strong>是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>&emsp;&emsp;通过以下例子来看并发和共享的关系：使用QQ发送文件A，同时使用微信发送文件B。两个进程正在并发执行（并发性），需要共享地访问硬盘资源（共享性）。如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义；如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发。因此，<strong>并发性和共享性是互为存在条件的</strong>。</p><h2 id="四、虚拟"><a href="#四、虚拟" class="headerlink" title="四、虚拟"></a>四、虚拟</h2><p>&emsp;&emsp;<strong>虚拟</strong>是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p><h3 id="1-虚拟技术——空分复用技术"><a href="#1-虚拟技术——空分复用技术" class="headerlink" title="1.虚拟技术——空分复用技术"></a>1.虚拟技术——空分复用技术</h3><p>&emsp;&emsp;背景知识：一个程序需要放入内存并给它分配CPU才能执行。用一个例子来理解：GTA5需要4GB的运行内存，QQ需要256MB的内存，网易云音乐需要256MB的内存……而电脑是4GB的内存（物理实体），这些程序同时运行需要的内存远大于4GB，那么为什么它们还可以在电脑上同时运行呢？这就是<strong>虚拟存储器技术</strong>（空分复用技术），实际只有4GB内存，但是在用户看来似乎远大于4GB。</p><h3 id="2-虚拟技术——时分复用技术"><a href="#2-虚拟技术——时分复用技术" class="headerlink" title="2.虚拟技术——时分复用技术"></a>2.虚拟技术——时分复用技术</h3><p>&emsp;&emsp;另一个例子，在某单核CPU的计算机中，用户打开了QQ、Chorme、QQ音乐、迅雷……，为什么单核CPU的电脑中能同时运行这么多个程序呢？这就是<strong>虚拟处理器技术</strong>（时分复用技术），实际上只有一个单核CPU，但是在用户看来似乎有多个CPU在同时为自己服务。</p><p>&emsp;&emsp;显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了，因此，<strong>没有并发性就谈不上虚拟性</strong>。</p><h2 id="五、异步"><a href="#五、异步" class="headerlink" title="五、异步"></a>五、异步</h2><p>&emsp;&emsp;异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><p>&emsp;&emsp;比如，当正在执行的进程提出某种资源请求时，如打印请求，而此时打印机正在为其他某进程打印，由于打印机属于临界资源，因此正在执行的进程必须等待，且放弃处理机，直到打印机空闲，并再次把处理机分配给该进程时，该进程方能继续执行。可见，由于资源等因素的限制，进程的执行通常都不是“一气呵成”，而是以“停停走走”的方式运行。是程序并发执行时，程序之间的相互制约关系导致了并发程序这种“执行——暂停——执行”这种间断性的活动规律。</p><p>&emsp;&emsp;如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底，<strong>只有系统拥有并发性，才有可能导致异步性</strong>。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>&emsp;&emsp;没有并发和共享，就谈不上虚拟和异步，因此并发和共享是操作系统的两个最基本的特征。</p><img src="总结.jpg" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统的概念、功能</title>
      <link href="/2023/12/10/One/"/>
      <url>/2023/12/10/One/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;对《操作系统》的知识梳理  一</p><span id="more"></span><h2 id="零、计算机系统的结构层次"><a href="#零、计算机系统的结构层次" class="headerlink" title="零、计算机系统的结构层次"></a>零、计算机系统的结构层次</h2><img src="计算机系统的结构层次.jpg"  /><h2 id="一、操作系统的概念"><a href="#一、操作系统的概念" class="headerlink" title="一、操作系统的概念"></a>一、操作系统的概念</h2><p>&emsp;&emsp;操作系统(Operating System,OS)是指控制和<strong>管理</strong>整个计算机系统的<strong>硬件和软件资源</strong>，并合理地组织调动计算机的工作和资源的分配；以<strong>提供给用户和其他软件方便的接口和环境</strong>；它是计算机系统中最基本的系统软件。</p><p>&emsp;&emsp;例如：Windows操作系统的“任务管理器”</p><img src="例一.jpg" style="zoom:67%;" /><p>&emsp;&emsp;这个界面就可以看到正在运行的进程有哪些，还可以看到它们对CPU、内存等等硬件的使用情况。表现了操作系统对硬件和软件的管理者，同时它还向上层提供了方便易用的服务，是最接近硬件的一层软件。</p><h2 id="二、操作系统的功能和目标"><a href="#二、操作系统的功能和目标" class="headerlink" title="二、操作系统的功能和目标"></a>二、操作系统的功能和目标</h2><h3 id="1、作为系统资源的管理者"><a href="#1、作为系统资源的管理者" class="headerlink" title="1、作为系统资源的管理者"></a>1、作为系统资源的管理者</h3><p>&emsp;&emsp;操作系统作为系统资源的管理者，它的功能和目标如下所示：</p><img src="操作系统的功能和目标1.jpg" style="zoom:67%;" /><p>&emsp;&emsp;下面以实现QQ和朋友视频聊天的过程为例：</p><ul><li><p>在各个文件夹中找到QQ安装的位置</p></li><li><p>双击打开QQ.exe</p></li><li><p>QQ程序正常运行</p></li><li><p>开始和朋友视频聊天</p><p>第一步，逐层打开文件夹，找到QQ.exe这个程序的存放位置（<strong>操作系统的文件管理功能</strong>）。</p><p>第二步，双击打开QQ.exe的时候，操作系统会帮助我们把这个程序放到内存中（执行一个程序前，需要将该程序放到内存中，才能被CPU处理。<strong>操作系统的存储管理</strong>）。</p><p>第三步，QQ程序正常运行的时候，对应的进程被处理机（CPU）处理（<strong>操作系统的处理机管理</strong>）。</p><p>第四步，在视频聊天的过程中，操作系统把摄像头等设备资源分配给QQ使用（<strong>操作系统的设备管理</strong>）。</p></li></ul><p>在操作系统的学习中，主要就是学习它作为系统资源的管理者怎样实现这四个功能。</p><h3 id="2-向上层提供方便易用的服务"><a href="#2-向上层提供方便易用的服务" class="headerlink" title="2.向上层提供方便易用的服务"></a>2.向上层提供方便易用的服务</h3><img src="操作系统的功能和目标2.jpg" style="zoom:67%;" /><h4 id="1-GUI：图形化用户接口"><a href="#1-GUI：图形化用户接口" class="headerlink" title="1. GUI：图形化用户接口"></a>1. GUI：图形化用户接口</h4><p>&emsp;&emsp;用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。例如：在Windows操作系统中，删除一个文件只需要把文件“拖拽”到回收站即可。</p><h4 id="2-命令接口"><a href="#2-命令接口" class="headerlink" title="2.命令接口"></a>2.命令接口</h4><p>&emsp;&emsp;在一些早期的操作系统中，让用户用命令接口的方式进行交互。</p><h5 id="emsp-emsp-1-联机命令接口实例（Windows系统）"><a href="#emsp-emsp-1-联机命令接口实例（Windows系统）" class="headerlink" title="&emsp;&emsp;1.联机命令接口实例（Windows系统）"></a>&emsp;&emsp;1.联机命令接口实例（Windows系统）</h5><p>&emsp;&emsp;联机命令接口 &#x3D; 交互式命令接口</p><p>&emsp;&emsp;特点：用户说一句，系统跟着做一句。例如，Windows系统中win+R，输入cmd打开命令解释器，使用time命令。</p><h5 id="emsp-emsp-2-脱机命令接口实例（Windows系统）"><a href="#emsp-emsp-2-脱机命令接口实例（Windows系统）" class="headerlink" title="&emsp;&emsp;2. 脱机命令接口实例（Windows系统）"></a>&emsp;&emsp;2. 脱机命令接口实例（Windows系统）</h5><p>&emsp;&emsp;脱机命令接口 &#x3D; 批处理命令接口</p><p>&emsp;&emsp;特点：用户说一堆，系统跟着做一堆。例如，运行*.bat文件。</p><h4 id="3-程序接口（即系统调用又称广义指令）"><a href="#3-程序接口（即系统调用又称广义指令）" class="headerlink" title="3.程序接口（即系统调用又称广义指令）"></a>3.程序接口（即系统调用又称广义指令）</h4><p>&emsp;&emsp;可以在程序中进行系统调用来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用。如：C语言中“Hello World”程序时，在 printf 函数的底层就使用到了操作系统提供的显式相关的“系统调用”</p><h3 id="3-作为最接近硬件的层次"><a href="#3-作为最接近硬件的层次" class="headerlink" title="3.作为最接近硬件的层次"></a>3.作为最接近硬件的层次</h3><p>&emsp;&emsp;需要实现实现<strong>对硬件机器的拓展</strong>。</p><p>&emsp;&emsp;没有任何软件支持的计算机称为<strong>裸机</strong>。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。</p><p>&emsp;&emsp;通常把覆盖了软件的机器称为<strong>扩充机器</strong>，又称之为<strong>虚拟机</strong>。</p><p>&emsp;&emsp;操作系统对硬件机器的拓展：将CPU、内存、磁盘、显示器、键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><img src="总结.jpg" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空想家</title>
      <link href="/2023/12/09/all/"/>
      <url>/2023/12/09/all/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;<strong>学计算机一定要有一个非常强大的心理状态：计算机的所有东西都是人做出来的，别人能想出来的，我也一定能想得出来。</strong></p><p>&emsp;&emsp;<strong>在计算机里头，没有任何黑魔法。所有的东西，只不过是我现在不知道而已，总有一天，我会把所有的细节、所有的内部的东西，全都搞明白的。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于mediapipe的姿态识别和简单行为识别</title>
      <link href="/2023/12/07/Zero/"/>
      <url>/2023/12/07/Zero/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;本文是基于mediapipe的姿态识别和简单行为识别，通过对人体姿态关键点的坐标的使用，实现简单的举手检测，其行为检测的精度主要取决于mediapipe关键点的检测精度。</p><span id="more"></span><h2 id="一、mediapipe的安装"><a href="#一、mediapipe的安装" class="headerlink" title="一、mediapipe的安装"></a>一、mediapipe的安装</h2><p>&emsp;&emsp;以Pycharm为例，直接在终端里面输入指令</p><blockquote><p>pip install  mediapipe</p></blockquote><p>&emsp;&emsp;等待下载完毕即可</p><h2 id="二、使用mediapipe检测关键点"><a href="#二、使用mediapipe检测关键点" class="headerlink" title="二、使用mediapipe检测关键点"></a>二、使用mediapipe检测关键点</h2><h3 id="1-mediapipe的介绍"><a href="#1-mediapipe的介绍" class="headerlink" title="1.mediapipe的介绍"></a>1.mediapipe的介绍</h3><p>   &emsp;&emsp;Mediapipe是一个用于构建机器学习管道的框架，用户处理视频、音频等时间序列数据。这个跨平台框架使用于桌面&#x2F;服务器、Android、ios和各类嵌入式设备。</p><p>   &emsp;&emsp;目前mediapipe包含以下16个solution，总的来说，mediapipe是一个很好的库，可以解决ML项目中面临的大部分麻烦，而且很适合做行为识别方向练手使用。</p><blockquote><p>1.人脸检测</p><p>2.Face Mesh</p><p>3.虹膜</p><p>4.手</p><p>5.姿态</p><p>6.人体</p><p>7.人物分割</p><p>8.头发分割</p><p>9.目标检测</p><p>10.Box Tracking</p><p>11.instant Motion Tracking</p><p>12.3D目标检测</p><p>13.特征匹配</p><p>14.AutoFlip</p><p>15.MediaSequence</p><p>16.YouTuBe_8M</p></blockquote><h3 id="2-使用mediapipe检测人体"><a href="#2-使用mediapipe检测人体" class="headerlink" title="2.使用mediapipe检测人体"></a>2.使用mediapipe检测人体</h3><p>&emsp;&emsp;这里仅使用mediapipe关于人体识别的方法（solution），谷歌官方将这种人体姿态识别的方法叫做Blazepose。</p><h4 id="（1）-检测前的准备工作"><a href="#（1）-检测前的准备工作" class="headerlink" title="（1） 检测前的准备工作"></a>（1） 检测前的准备工作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;导入一些基本的库&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> mediapipe <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFont, ImageDraw</span><br><span class="line"><span class="comment"># ------------------------------------------------</span></span><br><span class="line"><span class="comment">#   mediapipe的初始化</span></span><br><span class="line"><span class="comment"># 这一步是必须的，因为要使用到以下定义的几个类</span></span><br><span class="line"><span class="comment">#   具体的函数参数意义可以参考第三方资料</span></span><br><span class="line"><span class="comment"># ------------------------------------------------</span></span><br><span class="line">mp_pose = mp.solutions.pose</span><br><span class="line">mp_drawing = mp.solutions.drawing_utils</span><br><span class="line">pose = mp_pose.Pose(static_image_mode=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="（2）检测图片"><a href="#（2）检测图片" class="headerlink" title="（2）检测图片"></a>（2）检测图片</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_frame</span>(<span class="params">img</span>):</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    h, w = img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>] <span class="comment"># 高和宽</span></span><br><span class="line">    <span class="comment"># 调整字体</span></span><br><span class="line">    tl = <span class="built_in">round</span>(<span class="number">0.005</span> * (img.shape[<span class="number">0</span>] + img.shape[<span class="number">1</span>]) / <span class="number">2</span>) + <span class="number">1</span></span><br><span class="line">    tf = <span class="built_in">max</span>(tl-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># BRG--&gt;RGB</span></span><br><span class="line">    img_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line">    <span class="comment"># 将RGB图像输入模型，获取 关键点 预测结果</span></span><br><span class="line">    results = pose.process(img_RGB)</span><br><span class="line">    keypoints = [<span class="string">&#x27;&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>)]</span><br><span class="line">    <span class="keyword">if</span> results.pose_landmarks:</span><br><span class="line">        mp_drawing.draw_landmarks(img, results.pose_landmarks, mp_pose.POSE_CONNECTIONS)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>):</span><br><span class="line">            cx = <span class="built_in">int</span>(results.pose_landmarks.landmark[i].x * w)</span><br><span class="line">            cy = <span class="built_in">int</span>(results.pose_landmarks.landmark[i].y * h)</span><br><span class="line">            keypoints[i] = (cx, cy)</span><br><span class="line">            <span class="comment"># 得到最终的33个关键点</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;NO PERSON&quot;</span>)</span><br><span class="line">        struction = <span class="string">&quot;NO PERSON&quot;</span></span><br><span class="line">        img = cv2.putText(img, struction, (<span class="number">25</span>, <span class="number">100</span>), cv2.FONT_HERSHEY_SIMPLEX, <span class="number">1.25</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>),</span><br><span class="line">                          <span class="number">6</span>)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    process_time = end_time - start_time</span><br><span class="line">    <span class="comment"># 图片关键点预测时间</span></span><br><span class="line">    fps = <span class="number">1</span> / process_time</span><br><span class="line">    <span class="comment"># 帧率</span></span><br><span class="line">    colors = [[random.randint(<span class="number">0</span>,<span class="number">255</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>)]</span><br><span class="line">    radius = [random.randint(<span class="number">8</span>,<span class="number">15</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>):</span><br><span class="line">        cx, cy = keypoints[i]</span><br><span class="line">        <span class="comment">#if i in range(33):</span></span><br><span class="line">        img = cv2.circle(img, (cx, cy), radius[i], colors[i], -<span class="number">1</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;str_pose = get_pos(keypoints)#获取姿态</span></span><br><span class="line"><span class="string">    cv2.putText(img, &quot;POSE-&#123;&#125;&quot;.format(str_pose), (12, 100), cv2.FONT_HERSHEY_TRIPLEX,</span></span><br><span class="line"><span class="string">                tl / 3, (255, 0, 0), thickness=tf)&#x27;&#x27;&#x27;</span></span><br><span class="line">    cv2.putText(img, <span class="string">&quot;FPS-&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="built_in">int</span>(fps))), (<span class="number">12</span>, <span class="number">100</span>), cv2.FONT_HERSHEY_SIMPLEX,</span><br><span class="line">                tl/<span class="number">3</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>),thickness=tf)</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  &emsp;&emsp; 如果需要执行代码，则加入主函数使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">img0 = cv2.imread(<span class="string">&quot;./data/outImage--20.jpg&quot;</span>)</span><br><span class="line">    image = cv2.imdecode(np.fromfile(image_path, dtype=np.uint8), -<span class="number">1</span>)</span><br><span class="line">    img = image.copy()</span><br><span class="line">    image = process_frame(img)</span><br><span class="line">    <span class="comment"># 使用matplotlib画图    </span></span><br><span class="line">    fig, axes = plt.subplots(nrows=<span class="number">1</span>, ncols=<span class="number">2</span>)</span><br><span class="line">    axes[<span class="number">0</span>].imshow(img0[:,:,::-<span class="number">1</span>])</span><br><span class="line">    axes[<span class="number">0</span>].set_title(<span class="string">&quot;原图&quot;</span>)</span><br><span class="line">    axes[<span class="number">1</span>].imshow(image[:,:,::-<span class="number">1</span>])</span><br><span class="line">    axes[<span class="number">1</span>].set_title(<span class="string">&quot;检测并可视化后的图片&quot;</span>)</span><br><span class="line">    plt.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">    plt.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>] = <span class="literal">False</span></span><br><span class="line">    plt.show()</span><br><span class="line">    fig.savefig(<span class="string">&quot;./data/out.png&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="（3）检测视频"><a href="#（3）检测视频" class="headerlink" title="（3）检测视频"></a>（3）检测视频</h4><p>&emsp;&emsp;任何不涉及3D卷积的机器视觉方法，检测视频其实就是检测图片，因为视频是由多帧图片融合得来的。比如说一个30帧的视频，那么它的每一秒钟，就是由30张图片叠加而成。将这些分割出的图片分别进行检测，最后将检测的图片进行融合，得到的就是检测后的视频。有了这个依据，我们就可以把图片检测过程写成一个函数，在视频的每一帧中调用这个函数就可以了。</p><p>&emsp;&emsp;一般使用OpenCV库将视频分解为图片帧的形式，示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">video2image</span>(<span class="params">videoPath=<span class="string">&quot;./video/demo1.mp4&quot;</span>,</span></span><br><span class="line"><span class="params">                image_dir=<span class="string">&quot;./image&quot;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;videoPath是视频路径， image_dir是图片保存的文件夹路径&#x27;&#x27;&#x27;</span></span><br><span class="line">    cap = cv2.VideoCapture(videoPath)</span><br><span class="line">    frame_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(cap.isOpened()):</span><br><span class="line">        success,frame = cap.read()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> success:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        frame_count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;视频总帧数：&quot;</span>, frame_count)</span><br><span class="line">    cap.release()</span><br><span class="line">    cap = cv2.VideoCapture(videoPath)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> tqdm(total=frame_count-<span class="number">1</span>) <span class="keyword">as</span> pbar:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span>(cap.isOpened()):</span><br><span class="line">                success, frame = cap.read()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> success:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment">#处理帧</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">if</span> count % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">                        cv2.imwrite(<span class="string">&quot;&#123;&#125;/outImage--&#123;&#125;.jpg&quot;</span>.<span class="built_in">format</span>(image_dir, count), frame)</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">if</span> success == <span class="literal">True</span>:</span><br><span class="line">                    pbar.update(<span class="number">1</span>)</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;中途中断&quot;</span>)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line">    cap.release()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;视频已经处理结束，进行下一步操作！！！&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么落实到本文想要实现的功能上，就可以在视频分解出的帧后面加上图片检测函数。<br>代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_video</span>(<span class="params">video_path=<span class="string">&quot;./Data.mp4&quot;</span></span>):</span><br><span class="line">    video_flag = <span class="literal">False</span></span><br><span class="line">    cap = cv2.VideoCapture(video_path)</span><br><span class="line">    out_path = <span class="string">&quot;./out_Data.mp4&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;视频开始处理……&quot;</span>)</span><br><span class="line">    frame_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (cap.isOpened()):</span><br><span class="line">        success, frame = cap.read()</span><br><span class="line">        frame_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> success:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    cap.release()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;总帧数 = &quot;</span>, frame_count)</span><br><span class="line">    cap = cv2.VideoCapture(video_path)</span><br><span class="line">    <span class="keyword">if</span> video_flag == <span class="literal">False</span>:</span><br><span class="line">        frame_size = cap.get(cv2.CAP_PROP_FRAME_WIDTH), cap.get(cv2.CAP_PROP_FRAME_HEIGHT)</span><br><span class="line">        <span class="comment">#处理图像的尺寸。</span></span><br><span class="line">        fourcc = cv2.VideoWriter_fourcc(*<span class="string">&#x27;mp4v&#x27;</span>)</span><br><span class="line">        <span class="comment">#保存视频文件的格式为mp4</span></span><br><span class="line">        fps = cap.get(cv2.CAP_PROP_FPS)</span><br><span class="line">        out = cv2.VideoWriter(out_path, fourcc, fps, (<span class="built_in">int</span>(frame_size[<span class="number">0</span>]),<span class="built_in">int</span>(frame_size[<span class="number">1</span>])), )</span><br><span class="line">        <span class="comment">#输出图像的句柄</span></span><br><span class="line">    <span class="keyword">with</span> tqdm(total=frame_count-<span class="number">1</span>) <span class="keyword">as</span> pbar:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> cap.isOpened():</span><br><span class="line">                success, frame = cap.read()</span><br><span class="line">                <span class="keyword">if</span> success:</span><br><span class="line">                    pbar.update(<span class="number">1</span>)</span><br><span class="line">                    frame = process_frame(frame)</span><br><span class="line">                    <span class="comment"># frame就是视频截取的帧，process_frame表示对其检测。</span></span><br><span class="line">                    cv2.namedWindow(<span class="string">&quot;frame&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">                    cv2.imshow(<span class="string">&quot;frame&quot;</span>, frame)</span><br><span class="line">                    out.write(frame)</span><br><span class="line">                    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="number">27</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;中途中断&quot;</span>)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    cap.release()</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line">    out.release()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;视频已保存至&quot;</span>, out_path)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="三、使用mediapipe-BlazePose检测自定义简单行为"><a href="#三、使用mediapipe-BlazePose检测自定义简单行为" class="headerlink" title="三、使用mediapipe-BlazePose检测自定义简单行为"></a>三、使用mediapipe-BlazePose检测自定义简单行为</h2><h3 id="1-原理介绍"><a href="#1-原理介绍" class="headerlink" title="1.原理介绍"></a>1.原理介绍</h3><p>&emsp;&emsp;将mediapipe用于行为检测是比较复杂的一件事；如果这样做，那么行为检测的精度完全取决于mediapipe关键点的检测精度，于是，可以根据下图中人的关节夹角来对人的姿势进行检测。</p><img src="人体关键点.jpg" alt="人体关键点" style="zoom:67%;" /><p>&emsp;&emsp;如举手的时候，手腕的15、16点应该是略高于0点，并且手臂于水平方向夹角一定是在80度到100度之间，那么这样就可以完成对举手动作的简单分类。</p><h3 id="2-实现过程"><a href="#2-实现过程" class="headerlink" title="2.实现过程"></a>2.实现过程</h3><p>&emsp;&emsp;首先要知道，由坐标求得矢量的公式，其实就是两个坐标相减。</p><p>&emsp;&emsp;如已知三点P0(x0,y0)、P1(x1,y1)和P2(x2,y2)，那么求P0P1和P0P2两个矢量之间的夹角公式,用代码描写如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v1 = (x1, y1) - (x2, y2)</span><br><span class="line">v2 = (x0, y0) - (x2, y2)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_angle</span>(<span class="params">v1, v2</span>):</span><br><span class="line">    angle = np.dot(v1, v2) / (np.sqrt(np.<span class="built_in">sum</span>(v1 * v1)) * np.sqrt(np.<span class="built_in">sum</span>(v2 * v2)))</span><br><span class="line">    angle = np.arccos(angle) / <span class="number">3.14</span> * <span class="number">180</span></span><br><span class="line"></span><br><span class="line">    cross = v2[<span class="number">0</span>] * v1[<span class="number">1</span>] - v2[<span class="number">1</span>] * v1[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> cross &lt; <span class="number">0</span>:</span><br><span class="line">        angle = - angle</span><br><span class="line">    <span class="keyword">return</span> angle</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样就可以得到两个矢量的夹角。</p><p>&emsp;&emsp;之后就可以通过夹角对行为进行判断，这里的规则是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_pos</span>(<span class="params">keypoints</span>):</span><br><span class="line">    str_pose = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 计算左臂与水平方向的夹角</span></span><br><span class="line">    keypoints = np.array(keypoints)</span><br><span class="line">    p_x_right, p_y_right = keypoints[<span class="number">16</span>]</span><br><span class="line">    p_x_left, p_y_left = keypoints[<span class="number">15</span>]</span><br><span class="line">    p_x_right_body, p_y_right_body = keypoints[<span class="number">11</span>]</span><br><span class="line">    p_x_left_body, p_y_left_body = keypoints[<span class="number">12</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> p_y_right &lt; p_y_right_body:</span><br><span class="line">        v1 = keypoints[<span class="number">14</span>] - keypoints[<span class="number">16</span>]</span><br><span class="line">        v2 = keypoints[<span class="number">12</span>] - keypoints[<span class="number">11</span>]</span><br><span class="line">        get_right_arm = <span class="built_in">abs</span>(get_angle(v1, v2))</span><br><span class="line">        <span class="comment"># print(&quot;R&#123;&#125;&quot;.format(get_right_arm))</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">60</span> &lt; get_right_arm &lt; <span class="number">120</span>:</span><br><span class="line">            str_pose = <span class="string">&quot;RIGHT RAISE&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> p_y_left &lt; p_y_left_body:</span><br><span class="line">        v1 = keypoints[<span class="number">13</span>] - keypoints[<span class="number">15</span>]</span><br><span class="line">        v2 = keypoints[<span class="number">11</span>] - keypoints[<span class="number">12</span>]</span><br><span class="line">        get_left_arm = <span class="built_in">abs</span>(get_angle(v1, v2))</span><br><span class="line">        <span class="comment"># print(&quot;L&#123;&#125;&quot;.format(get_left_arm))</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">60</span> &lt; get_left_arm &lt; <span class="number">120</span>:</span><br><span class="line">            str_pose = <span class="string">&quot;LEFT RAISE&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        str_pose = <span class="string">&quot;NO RAISE&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str_pose</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>&emsp;&emsp;得到的str_pose就是行为字符串，在process_frame中可以得到可视化结果。</p><h2 id="四、总结和一些结果展示"><a href="#四、总结和一些结果展示" class="headerlink" title="四、总结和一些结果展示"></a>四、总结和一些结果展示</h2><p>&emsp;&emsp;到这里，关键点检测与简单行为检测就已经全部结束了，这里是把基于tkinter的UI设计与mediapipe进行融合，实现可视化的交互过程，具体代码可以看<a href="https://github.com/LiuHongjie1/-mediapipe-.git">github</a>。</p><p>&emsp;&emsp;以下是一些样例 <del>感谢我的室友</del>。</p><img src="no raise.jpg" alt="no raise" style="zoom:67%;" /><img src="left raise.jpg" alt="left raise" style="zoom:67%;" /><img src="right raise.jpg" alt="right raise" style="zoom:67%;" /><p>2023年12月15日修改：增加视频检测，修改部分代码</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
