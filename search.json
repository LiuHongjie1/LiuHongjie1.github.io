[{"title":"线性表","url":"/2024/01/16/线性表/","content":"\n&emsp;&emsp;本篇是对数据结构线性表的知识梳理与简要总结。\n\n<!--more-->\n\n### 0、知识框架\n\n<img src=\"知识框架.jpg\" style=\"zoom:67%;\" />\n\n\n\n### 1、线性表的定义和基本操作\n\n#### &emsp;1.1 线性表的定义\n\n&emsp;&emsp;**线性表**是具有**相同**数据类型的n( n ≥ 0 ) 个数据元素的**有限序列**，其中n为表长，当n = 0时线性表是一个空表。若用L命名线性表，则其一般表示为\n$$\nL = (a_1,a_2,a_3,……,a_i,a_{i+1},……,a_n)\n$$\n式中，a₁是唯一的“ 第一个 ”数据元素，又称表头元素；an是唯一的一个“ 最后一个 ”数据元素，又称表尾元素。除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素有且仅有一个直接后继（“ 直接前驱 ”和“ 前驱 ”、“ 直接后继 ” 和 “ 后继 ”通常被视为同义词）。以上就是线性表的逻辑特性，这种线性有序的逻辑结构正是线性表的名字的由来。\n\n&emsp;&emsp;由此，我们得出线性表的**特点**如下。\n\n- 表中元素的个数有限。\n- 表中元素具有逻辑上的顺序性，表中元素有其先后次序。\n- 表中元素都是数据元素，每个元素都是单个元素。\n-  表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。\n- 表中元素具有抽象性，即仅讨论元素之间的逻辑关系，而不考虑元素究竟表示什么内容。\n\n&emsp;&emsp;注意：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两者属于不同层面的概念。\n\n\n\n#### &emsp;1.2 线性表的基本操作\n\n&emsp;&emsp;一个数据结构的基本操作是指其最核心、最基本的操作。其他较复杂的操作可通过调用其基本操作来实现。线性表的主要操作如下。\n\n&emsp;&emsp;InitList(&L)：初始化表。构造一个空的线性表。\n\n&emsp;&emsp;Length(L)：求表长。返回线性表L的长度，即L中数据元素的个数。\n\n&emsp;&emsp;LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。\n\n&emsp;&emsp;GetElem(L,i)：按位查找操作。获取表L中第 i 个位置的元素的值。\n\n&emsp;&emsp;ListInsert(&L,i,e)：插入操作。在表L中第 i 个位置插入指定元素e。\n\n&emsp;&emsp;ListDalete(&L,i,e)：删除操作。删除表L中第 i 个位置的元素，并用e返回删除元素的值。\n\n&emsp;&emsp;PrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。\n\n&emsp;&emsp;Empty(L)：判空操作。若L为空表，则返回true，否则返回false。\n\n&emsp;&emsp;DestroyList(&L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。\n\n\n\n### 2、线性表的顺序表示\n\n#### &emsp;2.1 顺序表的定义\n\n&emsp;&emsp;线性表的顺序存储又称**顺序表**。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。第1个元素存储在线性表的起始位置，**第i个元素存储位置后面紧接着存储的是第i+1个元素**，称i为元素ai在线性表中的位序。因此，线性表的特点是**表中元素的逻辑顺序与其物理顺序相同**。\n\n&emsp;&emsp;假设线性表L存储的起始位置为LOC(A)，sizeof(ElemType)是每个数据元素所占用存储空间的大小，则表L所对应的顺序存储如下所示。\n\n![](线性表的顺序存储结构.jpg)\n\n&emsp;&emsp;每个数据元素的存储位置都和线性表的起始位置相差一个和该数据元素的位序成正比的常数，因此，顺序表中的任意一个数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。通常用高级程序设计语言中的数据来描述线性表的顺序存储结构（注意：线性表中元素的位序是从1开始的，而数组中元素的下表是从0开始的）。\n\n&emsp;&emsp;假定线性表的元素类型为ElemType，则线性表的顺序存储类型描述为：\n\n```c\n#define MaxSize 50          //定义线性表的最大长度\ntypedef struct{\n    ElemType data[MaxSize]; //顺序表的元素\n    int length;             //顺序表的当前长度\n}SqList;                    //顺序表的类型定义\n```\n\n&emsp;&emsp;一维数组可以是静态分配的，也可以是动态分配的。在静态分配时，由于数组的大小和空间事先已经固定，一旦空间占满，再加入新的数据就会产生溢出，进而导致程序崩溃。\n\n&emsp;&emsp;而在动态分配时，存储数组的空间是在程序执行过程中通过动态分配语句分配的，一旦数据空间占满，就另外开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储数据空间的目的，而不需要为线性表一次性地划分所有空间。\n\n```c\n#define InitSize 100     //表长度的初始定义\ntypedef struct{\n    ElemType *data;      //指示动态分配数组的指针\n    int MaxSize,length;  //数组的最大容量和当前个数\n}SeqList;                //动态分配数组顺序表的类型定义\n```\n\n&emsp;&emsp;另外，C和C++的初始动态分配语句如下：\n\n```c\nC：\n    L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);\n\nC++:\n\tL.data = new ElemType[InitSize];\n```\n\n&emsp;&emsp;注意：动态分配并不是链式存储，它同样属于顺序存储结构，物理结构没有变化，依然是随机存取方式，只是分配的空间大小可以在运行时动态决定。\n\n&emsp;&emsp;顺序表最主要的特点是随机访问，即通过首地址和元素序号可在时间O(1)内找到指定的元素。\n\n&emsp;&emsp;顺序表的存储密度高，每个结点只存储数据元素。\n\n&emsp;&emsp;顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。\n\n\n\n#### &emsp;2.2 顺序表上基本操作的实现\n\n&emsp;&emsp;这里仅讨论顺序表的插入、删除和按值查找的算法，其他基本操作的算法都比较简单\n\n&emsp;&emsp;1. 插入操作\n\n&emsp;&emsp;在顺序表L的第 i (1 <= i <= L.length+1)个位置插入新元素e。若i的输入不合法，则返回false，表示插入失败；否则，将第 i 个元素及其后的所有元素依次往后移动一个位置，腾出一个空位置插入新元素e，顺序表长度增加1，插入成功，返回true。\n\n```c\nbool ListInsert(SqList &L,int i,ElemType e){\n    if(i < 1 || i > L.length + 1)          //判断i的范围是否有效\n        return false;\n    if(L.length >= MaxSize)                //当前存储空间已满，不能插入\n        return false;\n    for(int j = L.length ; j >= i ; j--)   //将第i个元素及之后的元素后移\n        L.data[j] = L.data[j-1];\n    L.data[i-1] = e;                       //在位置i处放入e\n    L.length++;                            //线性表长度加1\n    return true\n}\n```\n\n&emsp;&emsp;最好情况：在表尾插入（即i = n + 1），元素后移语句将不执行，时间复杂度为O(1)。\n\n&emsp;&emsp;最坏情况：在表头插入（即i = 1），元素后移语句将执行n次，时间复杂度为O(n)。\n\n&emsp;&emsp;平均情况：假设pi(pi = 1 / (n+1) )，是在第i个位置上插入一个结点的概率，则在长度为n的线性表中插入一个结点时，所需移动结点的平均次数为：\n$$\n\\sum^{n+1}_{i=1}p_i(n-i+1)=\\sum^{n+1}_{i=1}\\frac{1}{n+1}(n-i+1)=\\frac{1}{n+1}\\sum^{n+1}_{i=1}(n-i+1)=\\frac{1}{n+1}\\frac{n(n+1)}{2}=\\frac{n}{2}\n$$\n&emsp;&emsp;因此，顺序表插入算法的平均时间复杂度为O(n)。\n\n\n\n&emsp;&emsp;2. 删除操作\n\n&emsp;&emsp;删除顺序表L中的第 i (1 <= i <= L.length+1)个位置的元素，用引用变量e返回。若i的输入不合法，则返回false；否则，将被删元素赋给引用变量e，并将第i+1个元素及其后的所有元素依次往前移动一个位置，返回true。\n\n```c\nbool ListDelete(SqList &L,int i,Elemtype &e){\n    if(i<1||i>L.length)                  //判断i的范围是否有效\n        return false;\n    e = L.data[i-1];                     //将被删除的元素赋值给e\n    for(int j = i ; j < L.length ; j++)  //将第i个位置的元素前移\n        L.data[j-1] = L.data[j];\n    L.length--;                          //线性表长度减1\n    return true;\n}\n```\n\n&emsp;&emsp;最好情况：删除表尾元素（即 i = n），无须移动元素，时间复杂度为O(1)。\n\n&emsp;&emsp;最坏情况：删除表头元素（即 i = 1），需移动除表头元素外的所有元素，时间复杂度为O(n)。\n\n&emsp;&emsp;平均情况：假设pi（pi = 1 / n）是删除第 i 个位置上结点的概率，则在长度为n的线性表中删除一个结点时，所需移动结点的平均次数为\n$$\n\\sum^n_{n-1}p_i(n-i)=\\sum^n_{i=1}\\frac{1}{n}(n-i)=\\frac{1}{n}\\sum^n_{i=1}(n-i)=\\frac{1}{n}\\frac{n(n-1)}{2}=\\frac{n-1}{2}\n$$\n&emsp;&emsp;因此，顺序表删除算法的平均时间复杂度为O(n)。\n\n&emsp;&emsp;可见，顺序表中插入和删除操作的时间主要耗费在移动元素上，而移动元素的个数取决于插入和删除元素的位置。\n\n\n\n&emsp;&emsp;3. 按值查找（顺序查找）\n\n&emsp;&emsp;在顺序表L中查找第一个元素值等于e的元素，并返回其位序。\n\n```c\nint LocateElem(SqList L,ElemType e){\n    int i;\n    for(i = 0; i < L.length ; i++)\n        if(L.data[i] == e)\n            return i + 1;    //下表为i的元素值等于e，返回其位序i+1\n\treturn 0;                //退出循环，说明查找失败\n}\n```\n\n&emsp;&emsp;最好情况：查找的元素就在表头，仅需比较一次，时间复杂度为O(1)。\n\n&emsp;&emsp;最坏情况：查找的元素在表尾（或不存在）时，需要比较n次，时间复杂度为O(n)。\n\n&emsp;&emsp;平均情况：假设pi（pi = 1 / n）是查找的元素在第 i 个位置上结点的概率，则长度为n的线性表中查找值为e的元素所需比较的平均次数为\n$$\n\\sum^n_{i=1}p_i*i=\\sum^n_{i=1}\\frac{1}{n}*i=\\frac{1}{n}\\frac{n(n+1)}{2}=\\frac{n+1}{2}\n$$\n&emsp;&emsp;因此，顺序表按值查找算法的平均时间复杂度为O(n)。\n\n\n\n### 3、线性表的链式表达\n\n&emsp;&emsp;顺序表的存储位置可以用一个简单直观的公式表示，它可以随机存取表中任意一个元素，但插入和删除操作需要移动大量元素。链式存储线性表时，不需要使用地址连续的存储单元，即不要求逻辑上相邻的元素在物理位置上也相邻，它通过“ 链 ”建立起元素之间的逻辑关系，因此插入和删除操作不需要移动元素，而只需要修改指针，但也会失去顺序表可随机存取的优点。\n\n#### &emsp;3.1 单链表的定义\n\n&emsp;&emsp;线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身信息外，还需要存放一个指向其后继的指针。\n\n&emsp;&emsp;单链表中结点类型的描述如下：\n\n```c\ntypedef struct LNode{   //定义单链表结点类型\n    Elemtype data;      //数据域\n    struct Lnode *next; //指针域\n}LNode,*LinkList;\n```\n\n&emsp;&emsp;利用单链表可以解决顺序表需要大量连续存储单元的缺点，但单链表附加指针域，也存在浪费存储空间的缺点。由于单链表的元素离散地分布在存储空间中，所以单链表是非随机存取的存储结构，即不能直接找到表中某个特定的结点。查找某个特点的结点时，需要从表头开始遍历，因此查找。\n\n&emsp;&emsp;通常用头指针来标识一个单链表，如单链表L，头指针NULL时表示一个空表。此外，为了操作上的方便，在单链表第一个结点之前附加一个结点，称为头结点。头结点的数据源可以不设任何信息，也可以记录表长等信息。头结点的指针域指向线性表的第一个元素结点，如下所示：\n\n<img src=\"带头结点的单链表.jpg\" style=\"zoom:90%;\" />\n\n&emsp;&emsp;头结点和头指针的区分：不管带不带头结点，头指针都是始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。\n\n&emsp;&emsp;引入头结点后，可以带来两个优点：\n\n&emsp;&emsp;①由于第一个数据结点的位置被存放头结点的指针域中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。\n\n&emsp;&emsp;②无论链表是否为空，其头指针都是指向头结点的非空指针（空表中头结点的指针域为空），因此空表和非空表的处理也就得到了统一。\n\n\n\n#### &emsp;3.2 单链表上基本操作的实现\n\n##### &emsp;&emsp;1. 采用头插法建立单链表\n\n&emsp;&emsp;该方法从一个空表开始，生成新的结点，并将读取到的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头，即头结点之后，如下所示：\n\n<img src=\"头插法建立单链表.jpg\" style=\"zoom:100%;\" />\n\n&emsp;&emsp;头插法建立单链表的算法如下：\n\n```c\nLinkList List_HeadInsert(LinkList &L){    //逆向建立单链表\n    LNode *s; int x;\n    L = (LinkList)malloc(sizeof(LNode));  //创建头结点\n    L -> next = NULL;\t\t\t\t\t  //初始为空链表\n    scanf(\"%d\",&x);\t\t\t\t\t\t  //输入结点的值\n    while(x != 9999){\t\t\t\t\t  //输入9999表示结束\n        s = (LNode*)malloc(sizeof(LNode)) //创建新结点\n        s -> data = x;\n        s -> next = L -> next;\n        L -> next = s;\t\t\t\t\t  //将新结点插入表中，L为头指针\n        scanf(\"%d\",&x);\n    }\n    return L;\n}\n```\n\n&emsp;&emsp;采用头插法建立单链表时，读入数据的顺序与生成的链表中的元素的顺序是相反的。每个结点插入的时间为O(1)，设单链表长为n，则总时间复杂度为O(n)。\n\n\n\n##### &emsp;2. 采用尾插法建立单链表\n\n&emsp;&emsp;头插法建立单链表的算法虽然简单，但生成的链表中节点的次序和输入数据的顺序不一致。若希望两者次序一致，则可以采用尾插法。该方法将新结点插入到当前链表的表尾，为此必须增加一个尾指针r，使其始终指向当前链表的尾节点，如下所示：\n\n<img src=\"尾插法建立单链表.jpg\" style=\"zoom:100%;\" />\n\n&emsp;&emsp;尾插法建立单链表的算法如下：\n\n```c\nLinkList List_TailInsert(LinkList &L){     //正向建立单链表\n    int x;\t\t\t\t\t\t\t\t   //设元素类型为整型\n    L = (LinkList)malloc(sizeof(LNode));\n    LNode *s,*r = L;\t\t\t\t\t   //r为表尾指针\n    scanf(\"%d\",&x);\t\t\t\t\t\t   //输入结点的值\n    while(x != 9999){\t\t\t\t\t   //输入9999表示结束\n        s = (LNode*)malloc(sizeof(LNode));\n        s -> data = x;\n        r -> next = s;\n        r = s;\t\t\t\t\t\t\t\t//r指向新的表尾结点\n        scanf(\"%d\",&x);\n    }\n    r -> next = NULL;\t\t\t\t\t\t//尾节点指针置空\n    return L;\n}\n```\n\n&emsp;&emsp;因为附设了一个指向表尾节点的指针，故时间复杂度和头插法相同。\n\n\n\n##### &emsp;3. 按序号查找节点\n\n&emsp;&emsp;在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL。\n\n&emsp;&emsp;按序号查找结点值的算法如下：\n\n```c\nLNode *GetElem(LinkList L,int i){\n    if(i<1)\n        return NULL;\t\t\t//若i无效，则返回NULL\n    int j = 1;\t\t\t\t\t//计数，初始为1\n    LNode *p = L -> next;\t\t//第一个结点指针赋给p\n    while(p != NULL && j < i){\t//从第一个结点开始找，查找第i个结点\n        p = p -> next;\n        j++;\n    }\n    return p;\t\t//返回第i个结点的指针，若i大于表长则返回NULL\n}\n```\n\n&emsp;&emsp;按序号查找操作的时间复杂度为O(n)。\n\n\n\n##### &emsp;4. 按值查找表结点\n\n&emsp;&emsp;从单链表的第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针；若整个单链表中没有这样的结点，则返回NULL。\n\n&emsp;&emsp;按值查找表结点的算法如下：\n\n```c\nLNode *LocateElem(LinkList L,ElemType e){\n    LNode *p = L -> next;\n    while(p != NULL && p -> data != e) //从第i个结点开始查找data域为e的结点\n        p = p->next;\n    return p;   //找到后返回该结点指针，否则返回NULL\n}\n```\n\n&emsp;&emsp;按值查找操作的时间复杂度为O(n)。\n\n\n\n#####  &emsp;5. 插入结点操作\n\n&emsp;&emsp;插入结点操作将值为x的新结点插入到单链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i - 1个结点，再在其后插入新结点。\n\n&emsp;&emsp;算法首先调用按序号查找酸罐GetElem(L,i - 1)，查找第i - 1个结点。假设返回的第i - 1个结点为*p，然后令新结点 *s的指针域指向 *p的后继结点，再令结点 *p的指针域指向新插入的结点 *s。其操作过程如下所示：\n\n<img src=\"单链表的插入操作.jpg\" style=\"zoom:100%;\" />\n\n&emsp;&emsp;实现插入结点的代码片段如下：\n\n```c\np = GetElem(L,i-1);     //查找插入位置的前驱结点\ns -> next = p -> next;  //图中操作步骤1\np -> newxt = s;         //图中操作步骤2\n```\n\n&emsp;&emsp;**算法中，第2、3句顺序不能颠倒**，本算法主要时间开销在于查找第 i - 1个元素，时间复杂度为O(n)。若在给定的结点后面插入新结点，则时间复杂度仅为O(1)。\n\n###### &emsp;&emsp;拓展：对某一结点进行前插操作\n\n&emsp;&emsp;另外，对某一节点进行前插操作时（前插操作是在某结点的前面插入一个新结点，后插操作的定义刚好与之相反，在单链表插入算法中，通常都是采用后插操作），以上面算法为例，首先调用函数GetElem(  )找到第i - 1个结点，即插入结点的前驱结点后，再对其进行后插操作。由此可知，对结点的前插操作均可可转化为后插操作，前提是从单链表的头结点开始顺序查找到其前驱结点，时间复杂度为O(n)。\n\n&emsp;&emsp;此外，可采用另一种方式将其转化为后插操作来实现，设待插入结点为 *s，将 *s插入到 *p的前面。我们仍然将 *s插入到 *p的后面，然后将p->data和s->data交换，这样既满足了逻辑关系，又能将时间复杂度为O(1)。算法的代码片段如下：\n\n```c\n//将*s结点插入到*p之前的主要代码片段\ns -> next = p -> next;\t\t//修改指针域，不能颠倒\np -> next = s;\ntemp = p -> data;\t\t\t//交换数据域部分\np -> data = s -> data;\ns -> data = temp\n```\n\n\n\n##### &emsp;6. 删除结点操作\n\n&emsp;&emsp;删除结点操作是将单链表的第i个结点删除。先检查删除位置的合法性，后查找表中第i -1个结点，即被删结点的前驱结点，再将其删除。其操作过程如下所示：\n\n<img src=\"单链表结点的删除.jpg\" style=\"zoom:100%;\" />\n\n&emsp;&emsp;假设结点 *p为找到的被删结点的前驱结点，为实现这一操作后的逻辑关系变化，仅需修改 *p的指针域，即将 *p的指针域next指向 *q的下一结点。实现删除结点的代码片段如下：\n\n```c\np = GetElem(L,i-1);\t\t//查找删除位置的前驱结点\nq = p -> next;\t\t\t//令q指向被删除结点\np -> next = q -> next;  //将*q结点从链中“断开”\nfree(q);\t\t\t\t//释放结点的存储空间\n```\n\n&emsp;&emsp;和插入算法一样，该算法的主要时间也是耗费在查找操作上，时间复杂度为O(n)。\n\n###### &emsp;&emsp;拓展：删除结点 *p\n\n&emsp;&emsp;要删除某个给定结点 *p，通常的做法是先从链表的头结点开始顺序找到其前驱结点，然后执行删除操作，算法的时间复杂度为O(n)。\n\n&emsp;&emsp;其实，删除结点 *p的操作可用删除 *p的后继结点操作来实现，实质就是将其后继结点的值赋予其自身，然后删除后继结点，也能使得时间复杂度为O(1)。实现上述操作的代码片段如下：\n\n```c\nq = p -> next;\t\t\t\t\t//令q指向*p的后继结点\np -> data = p -> next -> data;  //用后继结点的数据域覆盖\np -> next =q -> next;\t\t\t//将*q结点从链中“断开”\nfree(q);\t\t\t\t\t\t//释放后继结点的存储空间\n```\n\n\n\n##### &emsp;7. 求表长操作\n\n&emsp;&emsp;求表长操作就是计算单链表中数据结点（不含头结点）的个数，需要从第一个结点开始顺序依次访问表中的每个结点，为此需要设置一个计算器变量，每访问一个结点，计数器加1，直到访问到空结点为止。算法的时间复杂度为O(n)。\n\n&emsp;&emsp;需要注意的是，因为单链表的长度是不包括头结点的，因此不带头结点和带头结点的单链表在求表长操作上会略有不同。对不带头结点的单链表，当表为空时，要单独处理。\n\n\n\n#### &emsp;3.3 双链表\n\n&emsp;&emsp;单链表结点中只有一个指向其后继的指针，使得单链表只能从头结点依次顺序地向后遍历。要访问某个结点的前驱结点（插入、删除操作时），只能从头开始遍历，访问后继结点的时间复杂度为O(1)，访问前驱结点的时间复杂度为O(n)。\n\n&emsp;&emsp;为了克服单链表的上述缺点，引入了双链表，双链表结点中有两个指针prior和next，分别指向其前驱结点和后继结点，如下所示：\n\n<img src=\"双链表示意图.jpg\" style=\"zoom:80%;\" />\n\n&emsp;&emsp;双链表中结点类型的描述如下：\n\n```c\ntypedef struct DNode{\t\t\t//定义双链表结点类型\n    ElemType data;\t\t\t\t//数据域\n    struct DNode *prior,*next;\t//前驱和后继指针\n}DNode, *DLinklist;\n```\n\n&emsp;&emsp;双链表在单链表的结点中增加了一个指向其前驱的prior指针，因此双链表中的按值查找和按位查找的操作与单链表的相同。但双链表在插入和删除操作的实现上，与单链表有着较大的不同。这是因为“链”变化时也需要对prior指针做出修改，其关键是保证在修改的过程中不断链。此外，双链表可以很方便地找到其前驱结点，因此，插入、删除操作的时间复杂度仅为O(1)。\n\n##### &emsp;&emsp;1. 双链表的插入操作\n\n&emsp;&emsp;在双链表中p所指的结点之后插入结点 *s，其指针的变化过程如下：\n\n<img src=\"双链表插入结果过程.jpg\" style=\"zoom:90%;\" />\n\n&emsp;&emsp;插入操作的代码片段如下：\n\n```c\ns -> next = p -> next;\t\t//将结点*s插入到结点*p之后\np -> next -> prior = s;\ns -> prior = p;\np -> next = s;\n```\n\n&emsp;&emsp;上述代码的语句顺序不是唯一的，但是也不是任意的，第1、2必须在第4步之前。\n\n\n\n##### &emsp;&emsp;2. 双链表的删除操作\n\n&emsp;&emsp;删除双链表中结点 *p的后继结点 *q，删除操作的代码片段如下：\n\n```c\np -> next = q -> next;\nq -> next -> prior = p;\nfree(q);\n```\n\n\n\n#### &emsp;3.4 循环链表\n\n##### &emsp;&emsp;1. 循环单链表\n\n&emsp;&emsp;循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环，如下：\n\n<img src=\"循环单链表.jpg\" style=\"zoom:80%;\" />\n\n&emsp;&emsp;在循环单链表中，表尾结点 *r 的next域指向L，故表中没有指针域为NULL的结点，因此，循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针。\n\n&emsp;&emsp;循环单链表的插入、删除算法与单链表的几乎一样，所不同的是若操作是在表尾进行，则执行的操作不同，以让单链表继续保持循环的性质。当然，正是因为循环链表是一个“环”，因此在任何一个位置上的插入和删除操作都是等价的，无须判断是否是表尾。\n\n&emsp;&emsp;在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任意一个结点开始遍历整个链表。有时对循环单链表不设头指针而仅设尾指针，以使得操作效率更高。其原因是，若设的是头指针，对在表尾插入元素需要O(n)的时间复杂度，而若设的是尾指针r，r -> next即为头指针，对在表头或表尾插入元素都只需要O(1)的时间复杂度。\n\n\n\n##### &emsp;&emsp;2.  循环双链表\n\n&emsp;&emsp;由循环单链表的定义不难推出循环双链表。不同的是在循环双链表中，头结点的prior指针还要指向表尾结点，如下所示：\n\n<img src=\"循环双链表.jpg\" style=\"zoom:80%;\" />\n\n&emsp;&emsp;在循环双链表L中，某结点 *p为尾结点时，p -> next == L；当循环双链表为空表时，其头结点的prior域和next域都等于L。\n\n\n\n#### &emsp;3.5 静态链表\n\n&emsp;&emsp;静态链表借助数组来描述线性表的链式存储结构，结点也有数据域data和指针域next，与前面所讲的链表中的指针不同的是，这里的指针是结点的相对地址（数组下标），又称游标。和顺序表一样，静态链表也要预先分配一块连续的内存空间。静态链表和单链表的对应关系如下所示：\n\n<img src=\"静态链表存储示意图.jpg\" style=\"zoom:80%;\" />\n\n&emsp;&emsp;静态链表结构类型的描述如下：\n\n```c\n#define MaxSize 50\t\t//静态链表的最大长度\ntypedef struct{\t\t\t//静态链表结构类型的定义\n    ElemType data;\t\t//存储数据元素\n    int next;\t\t\t//下一个元素的数组下标\n}SLinkList[MaxSize];\n```\n\n&emsp;&emsp;静态链表以next == -1 作为其结束的标志。静态链表的插入、删除操作与动态链表的相同，只需要修改指针，而不需要移动元素。\n\n\n\n#### &emsp;3.6 顺序表和链表的比较\n\n##### &emsp;&emsp;1. 存取（读写）方式\n\n&emsp;&emsp;顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素。例如在第i个位置上执行存或取的操作，顺序表仅需要一次访问，而链表则需从表头开始依次访问 i 次。\n\n##### &emsp;&emsp;2. 逻辑结构与物理结构\n\n&emsp;&emsp;采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也是相邻。而采用链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示。\n\n##### &emsp;&emsp;3. 查找、插入和删除操作\n\n&emsp;&emsp;对于按值查找，顺序表无序时，两者的时间复杂度均为O(n)；顺序表有序时，可采用折半查找，此时时间复杂度为O(log₂n)。\n\n&emsp;&emsp;对于按序号查找，顺序表支持随机访问，时间复杂度仅为O(1)。而链表的平均时间复杂度为O(n)。顺序表的插入、删除操作，平均需要移动半个表长的元素。链表的插入、删除操作，只需修改相关结点的指针域即可。由于链表的每个结点都带有指针域，故而存储密度不够大。\n\n##### &emsp;&emsp;4. 空间分配\n\n&emsp;&emsp;顺序存储在静态存储分配情形下，一旦存储空间装满就不能扩充，若再加入新元素，则会出现内存溢出，因此需要预先分配足够大的存储空间。预先分配过大，可能会导致顺序表后部大量闲置；预先分配过小，又会造成溢出。动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且若内存中没有更大块的连续存储空间，则会导致分配失败。链式存储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。\n\n##### &emsp;&emsp;在实际中应该怎样选取存储结构呢？\n\n###### &emsp;&emsp;1.基于存储的考虑\n\n&emsp;&emsp;难以估计线性表的长度或存储规模时，不宜采用顺序表；链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。\n\n###### &emsp;&emsp;2.基于运算的考虑\n\n&emsp;&emsp;在顺序表中按序号访问a1的时间复杂度为O(1)，而表按序号访问的时间复杂度为O(n)，因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。\n\n&emsp;&emsp;在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且表较长时，这一点是不应忽视的；在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然后者优于前者。\n\n###### &emsp;&emsp;3.基于环境的考虑\n\n&emsp;&emsp;顺序表容易实现，任何高级语言中都有数组类型:链表的操作是基于指针的，相对来讲，前者实现较为简单，这也是用户考虑的一个因素。\n\n&emsp;&emsp;总之，两种存储结构各有长短，选择哪一种由实际问题的主要因素决定。通常较稳定的线性表选择顺序存储，而频繁进行插入、删除操作的线性表(即动态性较强)宜选择链式存储。\n","tags":["数据结构"],"categories":["数据结构"]},{"title":"绪论","url":"/2024/01/15/绪论/","content":"\n&emsp;&emsp;本篇是对数据结构的基本概念以及算法和算法评价的总结。\n\n<!--more-->\n\n### 0、知识框架\n\n<img src=\"知识框架.jpg\" style=\"zoom:50%;\" />\n\n\n\n### 1、数据结构的基本概念\n\n#### &emsp;1.1  基本概念和术语\n\n##### &emsp;&emsp;1. 数据\n\n&emsp;&emsp;数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号集合。数据是计算机程序加工的原料。\n\n##### &emsp;&emsp;2. 数据元素\n\n&emsp;&emsp;数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。\n\n##### &emsp;&emsp;3. 数据对象\n\n&emsp;&emsp;数据对象是具有相同性质的数据元素的集合，是数据的一个子集。例如，整数数据对象是集合N = {0,±1,±2,…}。\n\n##### &emsp;&emsp;4. 数据类型\n\n&emsp;&emsp;数据类型是一个值的集合和定义在此集合上的一组操作的总称。\n\n&emsp;&emsp;1）**原子类型**。其值不可再分的数据类型。\n\n&emsp;&emsp;2）**结构类型**。其值可以再分解为若干成分（分量）的数据类型。\n\n&emsp;&emsp;3）**抽象数据类型**。抽象数据组织及与之相关的操作。\n\n##### &emsp;&emsp;5.数据结构\n\n&emsp;&emsp;数据结构是相互之间存在一种或多种特定关系的数据元素的集合。在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构(Structure)。**数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。**\n\n&emsp;&emsp;数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。\n\n<img src=\"数据逻辑结构分类图.jpg\" style=\"zoom:50%;\" />\n\n#### &emsp;1.2 数据结构三要素\n\n##### &emsp;&emsp;1. 数据的逻辑结构\n\n&emsp;&emsp;逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的。数据的逻辑结构分为线性结构和非线性结构，线性表是典型的线性结构；集合、树和图是典型的非线性结构。数据的逻辑结构分类如下所示。\n\n\n\n&emsp;&emsp;**集合**。结构中的数据元素之间除 “同属一个集合” 外，别无其他关系。\n\n&emsp;&emsp;**线性结构**。结构中的数据元素之间只存在一对一的关系。\n\n&emsp;&emsp;**树形结构**。结构中的数据元素之间存在一对多的关系。\n\n&emsp;&emsp;**网状结构或图状结构**。结构中的数据之间存在多对多的关系。\n\n##### &emsp;&emsp;2. 数据的存储结构\n\n&emsp;&emsp;存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是用计算机语言实现的逻辑结构，它依赖于计算机语言。数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储。\n\n&emsp;&emsp;1） **顺序存储**。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中。元素之间的关系由存储单元中，元素之间的关系由存储单元的邻接关系来体现。其优点是可以实现随机存取，每个元素占用最少的存储空间；缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。\n\n&emsp;&emsp;2）**链式存储**。不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。其优点是不会出现碎片现象，能充分利用所有存储单元；缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。\n\n&emsp;&emsp;3）**索引存储**。在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）。其优点是检索速度快；缺点是附加的索引表额外占用存储空间。另外，增加和删除数据时也要修改索引表，因而会花费较多的时间。\n\n&emsp;&emsp;4）**散列存储**。根据元素的关键字直接计算出该元素的存储地址，又称哈希(Hash)存储。其优点是检索、增加和删除结点的操作都很快；缺点是若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。\n\n##### &emsp;&emsp;3. 数据的运算\n\n&emsp;&emsp;施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。\n\n\n\n### 2、算法和算法评价\n\n#### &emsp;2.1 算法的基本概念\n\n&emsp;&emsp;算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。此外，一个算法还具有下列5个重要特征：\n\n&emsp;&emsp;1）**有穷性**。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间时间内完成。\n\n&emsp;&emsp;2）**确定性**。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。\n\n&emsp;&emsp;3）**可行性**。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。\n\n&emsp;&emsp;4）**输入**。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。\n\n&emsp;&emsp;5）**输出**。一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。\n\n&emsp;&emsp;通常，设计一个“好”的算法应考虑以下目标：\n\n&emsp;&emsp;1）**正确性**。算法应该能够正确地解决求解问题。\n\n&emsp;&emsp;2）**可读性**。算法应具有良好的可读性，以帮助人们理解。\n\n&emsp;&emsp;3）**健壮性**。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。\n\n&emsp;&emsp;4）**高效率与低存储量需求**。效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题规模相关。\n\n\n\n#### &emsp;2.2 算法效率的度量\n\n&emsp;&emsp;算法效率的度量是通过**时间复杂度**和**空间复杂度**来描述的。\n\n##### &emsp;&emsp;1. 时间复杂度\n\n&emsp;&emsp;一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为T(n)，它是该算法问题规模n的函数，时间复杂度主要分析T(n)的数量级。算法中基本运算（最深层循环内的语句）的频度与T(n)同数量级，因此通常采用算法中基本运算的频度f(n)来分析算法的时间复杂度（取f(n)中随n增长最快的项，将其系数置为1作为时间复杂度的度量。例如，f(n) = an³ + bn² + cn 的时间复杂度为O(n³)）。因此，算法的时间复杂度记为\n$$\nT(n) = O(f(n))\n$$\n式中，O的含义是T(n)的数量级，其严格的数学定义是：若T(n)和f(n)是定义在正整数集合上的两个函数，则存在正常数C和n₀，使得当n≥n₀时，都满足0≤T(n)≤Cf(n)。\n\n&emsp;&emsp;算法的时间复杂度不仅依赖于问题的规模n，也取决于待输入数据的性质（如输入数据元素的初始状态）。例如，在数组A[0...n-1]中，查找给定值k的算法大致如下：\n\n```c\ni = n - 1;\nwhile(i >= 0 && A[i] != k)\n    i--;\nreturn i;\n```\n\n&emsp;&emsp;该算法中语句3（基本运算）的频度不仅与问题规模n有关，而且与输入实例中A的各元素取值及k的取值有关：\n\n&emsp;&emsp;1. 若A中没有与k相等的元素，则语句3的频度f(n) = n。\n\n&emsp;&emsp;2.若A中的最后一个元素等于k，则语句3的频度f(n)是常数0.\n\n&emsp;&emsp;**最坏时间复杂度**是指在最坏的情况下，算法的时间复杂度。\n\n&emsp;&emsp;**平均时间复杂度**是指所有可能输入实例在等概率出现的情况下，算法的期望运行时间。\n\n&emsp;&emsp;**最好时间复杂度**是指在最好情况下，算法的时间复杂度。\n\n&emsp;&emsp;一般<u>总是考虑在最坏的情况下的时间复杂度</u>，以保证算法的运行时间不会比它更长。\n\n&emsp;&emsp;在分析一个程序的时间复杂性时，有以下两条规则：\n\n&emsp;&emsp;a）加法规则\n$$\nT(n) = T₁(n) + T₂(n) = O(f(n))+O(g(n))=O(max(f(n),g(n)))\n$$\n&emsp;&emsp;b）乘法规则\n$$\nT(n) =  T₁(n)*T₂(n) =O(f(n))*O(g(n)) = O(f(n)*g(n))\n$$\n &emsp;&emsp;常见的渐进时间复杂度为\n$$\nO(1) < O(log₂n) < O(n) < O(nlog₂n) <O(n²)<O(n³)<O(2^n)<O(n!)<O(n^n)\n$$\n\n\n##### &emsp;&emsp;2. 空间复杂度\n\n&emsp;&emsp;算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它是问题规模n的函数。记为\n$$\nS(n) = O(g(n))\n$$\n&emsp;&emsp;一个程序在执行时除需要存储空间来存放本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间。若输入数据所占空间只取决于问题本身，和算法无关，则只需分析除输入和程序之外的额外空间。\n\n&emsp;&emsp;算法原地工作是指算法所需的辅助空间为常量，即O(1)。\n\n\n\n### 3、归纳总结\n\n&emsp;&emsp;本章的重点是分析程序的时间复杂度。要掌握分析时间复杂度的方法和步骤。\n\n#### 3.1 循环主题中的变量参与循环条件的判断\n\n&emsp;&emsp;此类题应该找出主体语句中与T(n)成正比的循环变量，将之代入条件中进行计算。例如，\n\n```c\n1、\nint i = 1;\nwhile (i <= n)\n    i = i * 2;\n\n2、\nint y = 5;\nwhile ((y + 1) * (y + 1) < n)\n    y = y + 1;\n```\n\n&emsp;&emsp;例1中，i 乘以2的次数正是主体语句的执行次数t，因此有2^t≤n，取对数之后有t ≤ log₂n，则T(n) = O(log₂n)。\n\n&emsp;&emsp;例2中，y+1的次数恰好与T(n)成正比，记t为该程序的执行次数，并令t = y - 5，有y = t + 5，\n$$\n(t + 5 + 1)*(t + 5 + 1)<n\n$$\n得 t < √n - 6，即T(n) = O(√n)。\n\n\n\n#### 3.2 循环主体中变量与循环条件无关\n\n&emsp;&emsp;此类题可采用数学归纳法或直接累计循环次数。多层循环时，从内到外分析，忽略单步语句、条件判断语句，只关注主体语句的执行次数。\n\n&emsp;&emsp;此类问题又可分为递归程序和非递归程序：\n\n##### &emsp;1 递归程序\n\n&emsp;&emsp;一般使用公式进行递推。\n\n##### &emsp;2 非递归程序\n\n&emsp;&emsp;可以直接累计次数。\n","tags":["数据结构"],"categories":["数据结构"]},{"title":"基于mediapipe的姿态识别和简单行为识别","url":"/2023/12/07/基于mediapipe的姿态识别和简单行为识别/","content":"&emsp;&emsp;本文是基于mediapipe的姿态识别和简单行为识别，通过对人体姿态关键点的坐标的使用，实现简单的举手检测，其行为检测的精度主要取决于mediapipe关键点的检测精度。\n<!--more-->\n\n## 一、mediapipe的安装\n\n&emsp;&emsp;以Pycharm为例，直接在终端里面输入指令\n\n> pip install  mediapipe\n\n&emsp;&emsp;等待下载完毕即可\n\n\n\n## 二、使用mediapipe检测关键点\n\n### 1.mediapipe的介绍\n\n   &emsp;&emsp;Mediapipe是一个用于构建机器学习管道的框架，用户处理视频、音频等时间序列数据。这个跨平台框架使用于桌面/服务器、Android、ios和各类嵌入式设备。\n\n   &emsp;&emsp;目前mediapipe包含以下16个solution，总的来说，mediapipe是一个很好的库，可以解决ML项目中面临的大部分麻烦，而且很适合做行为识别方向练手使用。\n\n   > 1.人脸检测\n   >\n   > 2.Face Mesh\n   >\n   > 3.虹膜\n   >\n   > 4.手\n   >\n   > 5.姿态\n   >\n   > 6.人体\n   >\n   > 7.人物分割\n   >\n   > 8.头发分割\n   >\n   > 9.目标检测\n   >\n   > 10.Box Tracking\n   >\n   > 11.instant Motion Tracking\n   >\n   > 12.3D目标检测\n   >\n   > 13.特征匹配\n   >\n   > 14.AutoFlip\n   >\n   > 15.MediaSequence\n   >\n   > 16.YouTuBe_8M\n\n### 2.使用mediapipe检测人体\n\n&emsp;&emsp;这里仅使用mediapipe关于人体识别的方法（solution），谷歌官方将这种人体姿态识别的方法叫做Blazepose。\n\n#### （1） 检测前的准备工作\n\n```python\n   '''导入一些基本的库'''\n   import cv2\n   import mediapipe as mp\n   import time\n   from tqdm import tqdm\n   import numpy as np\n   from PIL import Image, ImageFont, ImageDraw\n   # ------------------------------------------------\n   #   mediapipe的初始化\n   # \t这一步是必须的，因为要使用到以下定义的几个类\n   #   具体的函数参数意义可以参考第三方资料\n   # ------------------------------------------------\n   mp_pose = mp.solutions.pose\n   mp_drawing = mp.solutions.drawing_utils\n   pose = mp_pose.Pose(static_image_mode=True)\n   \n```\n\n#### （2）检测图片\n\n```python\n   def process_frame(img):\n       start_time = time.time()\n       h, w = img.shape[0], img.shape[1] # 高和宽\n       # 调整字体\n       tl = round(0.005 * (img.shape[0] + img.shape[1]) / 2) + 1\n       tf = max(tl-1, 1)\n       # BRG-->RGB\n       img_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n       # 将RGB图像输入模型，获取 关键点 预测结果\n       results = pose.process(img_RGB)\n       keypoints = ['' for i in range(33)]\n       if results.pose_landmarks:\n           mp_drawing.draw_landmarks(img, results.pose_landmarks, mp_pose.POSE_CONNECTIONS)\n           for i in range(33):\n               cx = int(results.pose_landmarks.landmark[i].x * w)\n               cy = int(results.pose_landmarks.landmark[i].y * h)\n               keypoints[i] = (cx, cy)\n               # 得到最终的33个关键点\n       else:\n           print(\"NO PERSON\")\n           struction = \"NO PERSON\"\n           img = cv2.putText(img, struction, (25, 100), cv2.FONT_HERSHEY_SIMPLEX, 1.25, (255, 255, 0),\n                             6)\n       end_time = time.time()\n       process_time = end_time - start_time\n       # 图片关键点预测时间\n       fps = 1 / process_time\n       # 帧率\n       colors = [[random.randint(0,255) for _ in range(3)] for _ in range(33)]\n       radius = [random.randint(8,15) for _ in range(33)]\n       for i in range(33):\n           cx, cy = keypoints[i]\n           #if i in range(33):\n           img = cv2.circle(img, (cx, cy), radius[i], colors[i], -1)\n       '''str_pose = get_pos(keypoints)#获取姿态\n       cv2.putText(img, \"POSE-{}\".format(str_pose), (12, 100), cv2.FONT_HERSHEY_TRIPLEX,\n                   tl / 3, (255, 0, 0), thickness=tf)'''\n       cv2.putText(img, \"FPS-{}\".format(str(int(fps))), (12, 100), cv2.FONT_HERSHEY_SIMPLEX,\n                   tl/3, (255, 255, 0),thickness=tf)\n       return img\n   \n```\n\n  &emsp;&emsp; 如果需要执行代码，则加入主函数使用\n\n```python\n   if __name__ == '__main__':\n   \timg0 = cv2.imread(\"./data/outImage--20.jpg\")\n       image = cv2.imdecode(np.fromfile(image_path, dtype=np.uint8), -1)\n       img = image.copy()\n       image = process_frame(img)\n       # 使用matplotlib画图    \n       fig, axes = plt.subplots(nrows=1, ncols=2)\n       axes[0].imshow(img0[:,:,::-1])\n       axes[0].set_title(\"原图\")\n       axes[1].imshow(image[:,:,::-1])\n       axes[1].set_title(\"检测并可视化后的图片\")\n       plt.rcParams[\"font.sans-serif\"] = ['SimHei']\n       plt.rcParams[\"axes.unicode_minus\"] = False\n       plt.show()\n       fig.savefig(\"./data/out.png\")\n   \n```\n\n#### （3）检测视频\n\n&emsp;&emsp;任何不涉及3D卷积的机器视觉方法，检测视频其实就是检测图片，因为视频是由多帧图片融合得来的。比如说一个30帧的视频，那么它的每一秒钟，就是由30张图片叠加而成。将这些分割出的图片分别进行检测，最后将检测的图片进行融合，得到的就是检测后的视频。有了这个依据，我们就可以把图片检测过程写成一个函数，在视频的每一帧中调用这个函数就可以了。\n\n&emsp;&emsp;一般使用OpenCV库将视频分解为图片帧的形式，示例代码如下：\n\n```python\ndef video2image(videoPath=\"./video/demo1.mp4\",\n                image_dir=\"./image\"):\n    '''videoPath是视频路径， image_dir是图片保存的文件夹路径'''\n    cap = cv2.VideoCapture(videoPath)\n    frame_count = 0\n    while(cap.isOpened()):\n        success,frame = cap.read()\n        if not success:\n            break\n        frame_count += 1\n    print(\"视频总帧数：\", frame_count)\n    cap.release()\n    cap = cv2.VideoCapture(videoPath)\n    count = 0\n    with tqdm(total=frame_count-1) as pbar:\n        try:\n            while(cap.isOpened()):\n                success, frame = cap.read()\n                if not success:\n                    break\n                #处理帧\n                try:\n                    if count % 20 == 0:\n                        cv2.imwrite(\"{}/outImage--{}.jpg\".format(image_dir, count), frame)\n                except:\n                    print(\"error\")\n                    pass\n                if success == True:\n                    pbar.update(1)\n                    count+=1\n        except:\n            print(\"中途中断\")\n            pass\n    cv2.destroyAllWindows()\n    cap.release()\n    print(\"视频已经处理结束，进行下一步操作！！！\")\n\n```\n\n&emsp;&emsp;那么落实到本文想要实现的功能上，就可以在视频分解出的帧后面加上图片检测函数。\n代码如下所示：\n\n```python\ndef process_video(video_path=\"./Data.mp4\"):\n    video_flag = False\n    cap = cv2.VideoCapture(video_path)\n    out_path = \"./out_Data.mp4\"\n    print(\"视频开始处理……\")\n    frame_count = 0\n    while (cap.isOpened()):\n        success, frame = cap.read()\n        frame_count += 1\n        if not success:\n            break\n    cap.release()\n    print(\"总帧数 = \", frame_count)\n    cap = cv2.VideoCapture(video_path)\n    if video_flag == False:\n        frame_size = cap.get(cv2.CAP_PROP_FRAME_WIDTH), cap.get(cv2.CAP_PROP_FRAME_HEIGHT)\n        #处理图像的尺寸。\n        fourcc = cv2.VideoWriter_fourcc(*'mp4v')\n        #保存视频文件的格式为mp4\n        fps = cap.get(cv2.CAP_PROP_FPS)\n        out = cv2.VideoWriter(out_path, fourcc, fps, (int(frame_size[0]),int(frame_size[1])), )\n        #输出图像的句柄\n    with tqdm(total=frame_count-1) as pbar:\n        try:\n            while cap.isOpened():\n                success, frame = cap.read()\n                if success:\n                    pbar.update(1)\n                    frame = process_frame(frame)\n                    # frame就是视频截取的帧，process_frame表示对其检测。\n                    cv2.namedWindow(\"frame\", cv2.WINDOW_NORMAL)\n                    cv2.imshow(\"frame\", frame)\n                    out.write(frame)\n                    if cv2.waitKey(1) == 27:\n                        break\n                else:\n                    break\n        except:\n            print(\"中途中断\")\n            pass\n    cap.release()\n    cv2.destroyAllWindows()\n    out.release()\n    print(\"视频已保存至\", out_path)\n\n```\n\n## 三、使用mediapipe-BlazePose检测自定义简单行为\n\n### 1.原理介绍\n\n&emsp;&emsp;将mediapipe用于行为检测是比较复杂的一件事；如果这样做，那么行为检测的精度完全取决于mediapipe关键点的检测精度，于是，可以根据下图中人的关节夹角来对人的姿势进行检测。\n\n<img src=\"人体关键点.jpg\" alt=\"人体关键点\" style=\"zoom:67%;\" />\n\n&emsp;&emsp;如举手的时候，手腕的15、16点应该是略高于0点，并且手臂于水平方向夹角一定是在80度到100度之间，那么这样就可以完成对举手动作的简单分类。\n\n### 2.实现过程\n\n&emsp;&emsp;首先要知道，由坐标求得矢量的公式，其实就是两个坐标相减。\n\n&emsp;&emsp;如已知三点P0(x0,y0)、P1(x1,y1)和P2(x2,y2)，那么求P0P1和P0P2两个矢量之间的夹角公式,用代码描写如下：\n\n```python\nv1 = (x1, y1) - (x2, y2)\nv2 = (x0, y0) - (x2, y2)\ndef get_angle(v1, v2):\n    angle = np.dot(v1, v2) / (np.sqrt(np.sum(v1 * v1)) * np.sqrt(np.sum(v2 * v2)))\n    angle = np.arccos(angle) / 3.14 * 180\n\n    cross = v2[0] * v1[1] - v2[1] * v1[0]\n    if cross < 0:\n        angle = - angle\n    return angle\n\n```\n\n&emsp;&emsp;这样就可以得到两个矢量的夹角。\n\n&emsp;&emsp;之后就可以通过夹角对行为进行判断，这里的规则是：\n\n```python\ndef get_pos(keypoints):\n    str_pose = \"\"\n    # 计算左臂与水平方向的夹角\n    keypoints = np.array(keypoints)\n    p_x_right, p_y_right = keypoints[16]\n    p_x_left, p_y_left = keypoints[15]\n    p_x_right_body, p_y_right_body = keypoints[11]\n    p_x_left_body, p_y_left_body = keypoints[12]\n\n    if p_y_right < p_y_right_body:\n        v1 = keypoints[14] - keypoints[16]\n        v2 = keypoints[12] - keypoints[11]\n        get_right_arm = abs(get_angle(v1, v2))\n        # print(\"R{}\".format(get_right_arm))\n        if 60 < get_right_arm < 120:\n            str_pose = \"RIGHT RAISE\"\n    elif p_y_left < p_y_left_body:\n        v1 = keypoints[13] - keypoints[15]\n        v2 = keypoints[11] - keypoints[12]\n        get_left_arm = abs(get_angle(v1, v2))\n        # print(\"L{}\".format(get_left_arm))\n        if 60 < get_left_arm < 120:\n            str_pose = \"LEFT RAISE\"\n    else:\n        str_pose = \"NO RAISE\"\n\n    return str_pose\n    \n```\n\n&emsp;&emsp;得到的str_pose就是行为字符串，在process_frame中可以得到可视化结果。\n\n## 四、总结和一些结果展示\n\n&emsp;&emsp;到这里，关键点检测与简单行为检测就已经全部结束了，这里是把基于tkinter的UI设计与mediapipe进行融合，实现可视化的交互过程，具体代码可以看[github](https://github.com/LiuHongjie1/-mediapipe-.git)。\n\n&emsp;&emsp;以下是一些样例 ~~感谢我的室友~~。\n\n\n\n<img src=\"no raise.jpg\" alt=\"no raise\" style=\"zoom:67%;\" />\n\n<img src=\"left raise.jpg\" alt=\"left raise\" style=\"zoom:67%;\" />\n\n<img src=\"right raise.jpg\" alt=\"right raise\" style=\"zoom:67%;\" />\n\n\n\n\n\n2023年12月15日修改：增加视频检测，修改部分代码\n\n2023年12月25日修改：修改可视化窗口，优化部分代码\n","tags":["Python","机器学习"],"categories":["机器学习"]},{"title":"空想家","url":"/2023/12/07/空想家/","content":"\n&emsp;&emsp;**学计算机一定要有一个非常强大的心理状态：计算机的所有东西都是人做出来的，别人能想出来的，我也一定能想得出来。**\n\n&emsp;&emsp;**在计算机里头，没有任何黑魔法。所有的东西，只不过是我现在不知道而已，总有一天，我会把所有的细节、所有的内部的东西，全都搞明白的。**\n\n"}]