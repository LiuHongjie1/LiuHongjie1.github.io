[{"title":"5G网络架构与组网部署","url":"/2024/02/16/5G网络架构与组网部署/","content":"\n&emsp;&emsp;本篇是对大唐杯培训5G网络架构与组网部署1的知识梳理与简要总结。\n\n<!--more-->\n\n### 1、学习目标\n\n&emsp;&emsp;1. 掌握5G网络整体架构组成\n\n&emsp;&emsp;2. 掌握主要网元功能\n\n&emsp;&emsp;3. 了解网元接口关系\n\n&emsp;&emsp;4. 了解5G网络组网部署策略\n\n\n\n### 2、5G网络架构的演进趋势\n\n#### &emsp;2.1概述\n\n&emsp;&emsp;**5G移动通信系统包括5GC**(5G Core Network, 5G核心网)**和NG-RAN**(Next Generation Radio Access Network, 5G无线接入网)。**5G核心网与5G接入网通过NG接口连接**，实现控制面与用户面功能；**5G无线接入网之间通过Xn接口连接**，实现控制面和用户面功能。5G移动通信系统整体架构如下：\n\n<img src=\"5G移动通信系统整体架构.jpg\" style=\"zoom:80%;\" />\n\n&emsp;&emsp;注：gNB为5G通信基站，eNB为4G通信基站，ng-eNB为下一代无线接入网，指4G增强型基站，可以实现一部分5G基站的功能。AMF/UPF/SMF等为核心网网元，UPF主要实现用户面的功能，AMF和SMF负责控制面的功能。\n\n\n\n&emsp;&emsp;**4G移动通信系统包括EPC**(Evolved Packet Core network, 演进分组核心网)**和E-UTRAN**(Evolved Universal Terrestrial Radio Access Network, 演进通用陆地无线接入网络)。**演进分组核心网与演进通用陆地无线接入网络通过S1接口连接**，实现控制面与用户面功能；**演进通用陆地无线接入网络之间通过X2接口连接**，实现控制面和用户面功能。4G移动通信系统整体架构如下所示：\n\n<img src=\"4G移动通信系统整体架构.jpg\" style=\"zoom:80%;\" />\n\n&emsp;&emsp;注：MME/S-GW等为核心网网元，MME主要实现控制面实体，负责移动性管理（到了5G其一部分功能到了SMF），S-GW负责用户面的网关。\n\n\n\n&emsp;&emsp;总的来说，5G移动通信系统整体架构与4G整体架构类似。4G与5G移动通信系统整体结构对比如下所示：RAN网络引入CU、DU，组网更灵活，利于多小区的集中控制，利于多功能的实现。MEC(Multi-access Edge Connection, 多接入边缘计算)是支撑5G系统运行的关键技术。（[AAU,BBU,RRU区分与功能](https://blog.csdn.net/m0_57545912/article/details/125013038)）\n\n![](4G与5G移动通信系统整体架构对比.jpg)\n\n\n\n#### &emsp;2.2 网络架构演进的核心目标\n\n&emsp;&emsp;1. 实现从“互联网应用被动适应网络”向“网络主动、快速、灵活适应互联网应用”\n\n&emsp;&emsp;2. 网络和资源的部署将打破行政管理体制和传统组网思路的制约，转向以IDC为核心的新格局。\n\n&emsp;&emsp;3. 不同阶段**核心网技术特征与代表技术**如下所示：\n\n<img src=\"不同阶段核心网技术特征与代表技术.jpg\" style=\"zoom:80%;\" />\n\n\n\n#### &emsp;2.3 核心网架构演进\n\n&emsp;&emsp;移动通信系统核心网**从3G到4G的演进特点是取消了CS域**(Circuit Switch, 电路交换域)**只保留PS域**(Packet Switch, 分组交换域)。**4G移动通信系统实现了控制和承载相分离**（[4G核心网-CSDN博客](https://blog.csdn.net/zdwzzu2006/article/details/103878303)）。4G核心网架构如下所示：\n\n<img src=\"4G核心网架构.jpg\" style=\"zoom:80%;\" />\n\n&emsp;&emsp;5G核心网颠覆了4G核心网的设计思路。**5G核心网基于SBA实现**(Service Based Architecture, 基于服务架构)，**使用NFV技术灵活重构网络功能，使用SDN技术灵活构建数据转发通道，使用切边技术实现业务保障与资源利用率最大化，完全实现CUPS**(Control and User Plane Separation, 控制与用户面分离)，结合云技术全面支撑5G应用场景需求（[5G 网络架构（核心网）总结](https://blog.csdn.net/Yolandalt7777777/article/details/105852009)）。为了应对5G网络的发展要求，基于服务的5G核心网架构如下所示：\n\n<img src=\"5G核心网架构.jpg\" style=\"zoom:80%;\" />\n\n\n\n#### &emsp;2.4 无线接入网演进\n\n&emsp;&emsp;从2G(第二代移动通信系统)开始到现在的5G(第五代移动通信系统)，无线接入网技术一直处于变化之中，无线接入网的实现方式也呈现“分合分”的表象([无线接入网](https://developer.aliyun.com/article/1236736))。无线接入网的发展与演进如下所示：\n\n<img src=\"无线接入网发展与演进.jpg\" style=\"zoom:80%;\" />\n\n\n\n### 3、5G网元功能与接口\n\n\n\n### 4、5G网络组网部署\n","tags":["大唐杯"],"categories":["大唐杯"]},{"title":"栈、队列和数组","url":"/2024/01/19/栈、队列和数组/","content":"\n&emsp;&emsp;本篇是对数据结构栈、队列和数组的知识梳理与简要总结。\n\n<!--more-->\n\n### 0、知识框架\n\n<img src=\"知识框架.jpg\" style=\"zoom:50%;\" />\n\n\n\n### 1、栈\n\n#### &emsp;1.1 栈的基本概念\n\n##### &emsp;&emsp;1. 栈的定义\n\n&emsp;&emsp;栈（Stack）是只允许在一端进行插入或删除操作的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端（栈顶）进行插入和删除操作。\n\n&emsp;&emsp;**栈顶（Top）：线性表允许进行插入删除的那一端。**\n\n**&emsp;&emsp;栈底（Bottom）：固定的，不允许进行插入和删除的那一端。**\n\n**&emsp;&emsp;空栈：不含任何元素的空表。**\n\n&emsp;&emsp;栈的操作特性可以概括为**<u>后进先出</u>**。\n\n&emsp;&emsp;栈的数学性质：n个不同元素进栈，出栈元素不同排列的个数为：\n$$\n\\frac{1}{n+1}C^n_{2n}\n$$\n\n##### &emsp;&emsp;2. 栈的基本操作\n\n&emsp;&emsp;InitStack(&S)：初始化一个空栈。\n\n&emsp;&emsp;StackEmpty(S)：判断一个栈是否为空，若空返回True，否则返回False。\n\n&emsp;&emsp;Push(&S,x)：进栈，若栈未满，则将x加入使之成为新栈顶。\n\n&emsp;&emsp;Pop(&S,&x)：出栈，若栈非空，则弹出栈顶元素，并用x返回。\n\n&emsp;&emsp;GetTop(S,&x)：读栈顶元素，若栈非空，则用x返回栈顶元素。\n\n&emsp;&emsp;DestroyStack(&S)：销毁栈，并释放栈S占用的存储空间。\n\n\n\n#### &emsp;1.2 栈的顺序存储结构\n\n&emsp;&emsp;栈是一种操作受限的线性表，类似于线性表，它也有对应的两种存储方式。\n\n##### &emsp;&emsp;1. 顺序栈的实现\n\n&emsp;&emsp;采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针( top )指示当前栈顶元素的位置。\n\n&emsp;&emsp;栈的顺序存储类型可描述为：\n\n```c\n#define MaxSize 50\t\t\t//定义栈中元素的最大个数\ntypedef struct{\n    Elemtype data[MaxSize]; //存放栈中元素\n    int top;\t\t\t\t//栈顶指针\n}SqStack;\n```\n\n&emsp;&emsp;栈顶指针：S.top，初始时设置S.top = -1；栈顶元素S.data[S.top]。\n\n&emsp;&emsp;进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素。\n\n&emsp;&emsp;出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减1。\n\n&emsp;&emsp;栈空条件：S.top = -1；栈满条件：S.top = MaxSize - 1；栈长：S.top + 1。\n\n&emsp;&emsp;由于顺序栈的入栈操作受数组上界的约束，当对栈的最大使用空间估计不足时，有可能发生栈上溢，此时应及时向用户报告消息，以便及时处理，避免出错。\n\n##### &emsp;&emsp;2. 顺序栈的基本运算\n\n&emsp;&emsp;栈操作的示意图如下所示，a是空栈，c是A、B、C、D、E共5个元素依次入栈后的结果，d是c之后E、D、C的相继出栈，此时栈中还有2个元素，或许最近出栈的元素C、D、E仍在原来的单元存储着，但top指针已经指向了新的栈顶，元素C、D、E已不在栈中。\n\n<img src=\"栈顶指针和栈中元素之间的关系.jpg\" style=\"zoom:67%;\" />\n\n&emsp;&emsp;下面是顺序栈上常用的基本运算的实现。\n\n```c\n//(1)初始化\nvoid InitStack(SqStack &S){\n    S.top = -1; //初始化栈顶指针\n}\n//(2)判断栈空\nbool StackEmpty(SqStack S){\n    if(S.top = -1)\n        return true;//栈空\n    else\n        return false;//不空\n}\n//(3)进栈\nbool Push(SqStack &S,ElemType x){\n    if(S.top == MaxSize - 1)//栈满，报错\n        return false;\n    S.data[++S.top] = x; //指针先加1，再入栈\n    return true;\n}//当栈不满时，top先加1，再入栈。\n//(4)出栈\nbool Pop(SqStack &S,ElemType &x){\n    if(S.top == -1)\t\t\t//栈空，报错\n        return false;\n    x = S.data[S.top--];\t//先出栈，指针再减1\n    return true;\n}\n//(5)读栈顶元素\nbool GetTop(SqStack S,ElemType &x){\n    if(S.top == -1)\t\t//栈空，报错\n        return false;\n    x = S.data[S.top];\t//x记录栈顶元素\n    return true;\n}//仅读取栈顶元素，没有出栈操作，因此原栈顶元素依然保留在栈中\n```\n\n##### &emsp;&emsp;3. 共享栈\n\n&emsp;&emsp;利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两段，两个栈顶向共享空间的中间延伸，如下所示：\n\n<img src=\"两个顺序栈共享存储空间.jpg\" style=\"zoom:80%;\" />\n\n&emsp;&emsp;两个栈的栈顶指针都指向栈顶元素，top0 = -1时，0号栈为空，top1 = MaxSize时，1号栈为空；仅当两个栈顶指针相邻(top1 - top0 = 1)时，判断为栈满。当0号栈进栈时，top0先加1再赋值，1号栈进栈时，top1先减1再赋值；出栈时则刚好相反。\n\n&emsp;&emsp;共享栈是为了更有效地利用存储空间，两个栈的空间相互调节，只有在整个存储空间被占满时，才发生上溢。其存取数据的时间复杂度均为O(1)。\n\n\n\n#### &emsp;1.3 栈的链式存储结构\n\n&emsp;&emsp;采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行。这里规定链栈没有头结点，Lhead指向栈顶元素，如下所示：\n\n<img src=\"栈的链式存储.jpg.\" style=\"zoom:80%;\" />\n\n&emsp;&emsp;栈的链式存储类型可描述为\n\n```c\ntypedef struct Linknode{\n    ElemType data;\t\t\t//数据域\n    struct Linknode *next;\t//指针域\n}*LiStack;\t\t\t\t\t//栈类型定义\n```\n\n&emsp;&emsp;采用链式存储，便于结点的插入与删除。链栈的操作与链表类似，入栈和出栈的操作都在链表的表头进行。需要注意的是，对于带头结点和不带头结点的链栈，具体实现会有所不同。\n\n\n\n### 2、队列\n\n#### &emsp;2.1 队列的基本概念\n\n##### &emsp;&emsp;1. 队列的定义\n\n&emsp;&emsp;队列(Queue)简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。向队列中插入元素称为*入队*或*进队*；删除元素称为*出队*或*离队*。这和我们日常生活中的排队是一致的，最早排队的也是最早离队的，其操作的特性是**先进先出**。\n\n&emsp;&emsp;队头(Front)。允许删除的一端，又称队首。\n\n&emsp;&emsp;队尾(Rear)。允许插入的一端。\n\n&emsp;&emsp;空队列。不含任何元素的空表。\n\n##### &emsp;&emsp;2. 队列常见的基本操作\n\n&emsp;&emsp;InitQueue(&Q)：初始化队列，构造一个空队列Q。\n\n&emsp;&emsp;QueueEmpty(Q)：判断队列是否为空，若空返回True，否则返回False。\n\n&emsp;&emsp;EnQueue(&Q,x)：入队，若队列未满，将x加入，使之成为新的队尾。\n\n&emsp;&emsp;DeQueue(&Q,&x)：出队，若队列非空，删除对头元素，并用x返回。\n\n&emsp;&emsp;GetHead(Q,&x)：读队头元素，若队列Q非空，则将队头元素赋值给x。\n\n&emsp;&emsp;**需要注意的是：栈和队列是操作受限的线性表，因此不是任何对线性表的操作都可以作为栈和队列的操作。比如，不可以随便读取栈或队列中间的某个数据。**\n\n\n\n#### &emsp;2.2 队列的顺序存储结构\n\n##### &emsp;&emsp;1. 队列的顺序存储\n\n&emsp;&emsp;队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针front指向队头元素，队尾指针rear指向队尾元素的下一个位置（可以不一致）。\n\n&emsp;&emsp;队列的顺序存储类型可描述为：\n\n```c\n#define MaxSize 50\t\t\t\t//定义队列中元素的最大个数\ntypedef struct{\n        ElemType data[MaxSize];\t//存放队列元素\n        int front,rear;\t\t\t//队头指针和队尾指针\n}SqQueue;\n```\n\n&emsp;&emsp;初始时：Q.front = Q.rear = 0。\n\n&emsp;&emsp;进队操作：队不满时，先送值到队尾元素，再将队尾指针加1。\n\n&emsp;&emsp;出队操作：队不空时，先取队头元素值，再将队头指针加1。\n\n&emsp;&emsp;如下所示的队列初始状态，有Q.front == Q.rear ==0 成立，该条件可以作为判断队列为空的条件。但能否用Q.rear == MaxSize作为队列为满的条件呢？显然不能，d中，队列中仅有一个元素，仍满足该条件。这时入队出现“上溢出 ”，但这种溢出并不是真正的溢出，在data数组中依然存在可以存放元素的空位置，所以是一种“ 假溢出 ”。\n\n<img src=\"队列的操作.jpg\" style=\"zoom:80%;\" />\n\n##### &emsp;&emsp;2. 循环队列\n\n&emsp;&emsp;前面指出了顺序队列的缺点，这里引出循环队列的概念。将循环队列想象为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环，称为循环队列。当队首指针Q.front = MaxSize - 1后，再前进一个位置就自动到0，这可以利用除法取余运算来实现。\n\n&emsp;&emsp;初始时：Q.front = Q.rear =0。\n\n&emsp;&emsp;队首指针进1：Q.front = (Q.front + 1)%MaxSize。\n\n&emsp;&emsp;队尾指针进1：Q.rear = (Q.rear + 1)%MaxSize。\n\n&emsp;&emsp;队列长度：(Q.rear + MaxSize - Q.front)%Maxsize。\n\n&emsp;&emsp;出队入队时：指针都按顺时针方向进1。\n\n&emsp;&emsp;那么，循环队列队空和队满的判断条件是什么呢？显然，队空的条件是Q.front == Q.rear。若入队元素的速度快于出队元素的速度，则队尾指针很快就会赶上队首指针，如图d1所示，此时可以看出队满时也有Q.front == Q.rear。循环队列出入队示意图如下所示。\n\n&emsp;&emsp;为了区分是队空还是队满的情况，有三种处理方式：\n\n&emsp;&emsp;1. 牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是一种较为普遍的做法，约定以“ 队头指针在队尾指针的下一位置作为队满的标志 ”，如图d2所示。\n\n<img src=\"循环队列出入队示意图.jpg\" style=\"zoom:80%;\" />\n\n&emsp;&emsp;队满条件：(Q.rear + 1)%MaxSize == Q.front。\n\n&emsp;&emsp;队空条件：Q.front == Q.rear。\n\n&emsp;&emsp;队列中元素的个数：(Q.rear - Q.front + MaxSize)%MaxSize。\n\n&emsp;&emsp;2. 类型中增设表示元素个数的数据成员。这样，队空的条件为Q.size == 0；队满条件为Q.size == MaxSize。这两种情况都有Q.front == Q.rear。\n\n&emsp;&emsp;3. 类型中增设tag数据成员，以区分是队满还是队空。tag等于0时，若因删除导致Q.front == Q.rear，则队空；tag 等于1时，若因插入导致Q.front == Q.rear，则队为满。\n\n##### &emsp;&emsp;3. 循环队列的操作\n\n```c\n//(1)初始化\nvoid InitQueue(SqQueue &Q){\n    Q.rear = Q.front =0; //初始化队首、队尾指针\n}\n//(2)判断队空\nbool isEmpty(SqQueue Q){\n    if(Q.rear == Q.front)  //队空条件\n        return true;\n    else\n        return false;\n}\n//(3)入队\nbool EnQueue(SqQueue &Q,ElemType x){\n    if((Q.rear + 1)%MaxSize == Q.front) //队满报错\n        return false;\n    Q.data[Q.rear] = x;\n    Q.rear=(Q.rear + 1) %MaxSize;\t\t//队尾指针+1取模\n    return true;\n}\n//(4)出队\nbool DeQueue(SqQueue &Q,ElemType &x){\n    if(Q.rear ==Q.front)\t// 队空报错 \n        return false;\n    x = Q.data[Q.front];\n    Q.front =(Q.front + 1) % MaxSize;  //队头指针+1取模\n    return true;\n}\n```\n\n\n\n#### &emsp;2.3 队列的链式存储结构\n\n##### &emsp;&emsp;1. 队列的链式存储\n\n&emsp;&emsp;队列的链式表示称为链队列，它实际上是一个同时带有队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点（注意与顺序存储不同）。队列的链式存储如下所示：\n\n<img src=\"不带头结点的链式队列.jpg\" style=\"zoom:90%;\" />\n\n&emsp;&emsp;队列的链式存储类型可描述为：\n\n```c\ntypedef struct LinkNode{\t//链式队列结点\n    ElemType data;\n    struct LinkNode *next;\n}LinkNode;\ntypedef struct{\t\t\t\t//链式队列\n    LinkNode *front,*rear;\t//队列的队头和队尾指针\n}*LinkQueue;\n```\n\n&emsp;&emsp;出队时，首先判断队是否为空，若不空，则取出队头元素，将其从链表中摘除，并让Q.front指向下一个结点（若该结点为最后一个结点，则置Q.front和Q.rear都为NULL）。入队时，建立一个新结点，将新结点插入到链表的尾部，并让Q.rear指向这个新插入的结点（若原队列为空队，则令Q.front也指向该结点）。\n\n&emsp;&emsp;不难看出，不带头结点的链式队列在操作上往往比较麻烦，因此通常将链式队列设计成一个带头结点的单链表，这样插入和删除操作就统一了。\n\n&emsp;&emsp;用单链表表示的链式队列特别适用于数据元素变动比较大的情形，而且不存在队列满且产生溢出的问题。另外，假如程序中要使用多个队列，与多个栈的情形一样，最好使用链式队列，这样就不会出现存储分配不合理和“ 溢出 ”的问题。\n\n##### &emsp;&emsp;2. 链式队列的基本操作\n\n```c\n//(1)初始化\nvoid InitQueue(LinkQueue &Q){\n    Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode));//建立头结点\n    Q.front -> next = NULL;  //初始为空\n}\n//(2)判断队列空\nvoid EnQueue(LinkQueue &Q,ElemType x){\n    if(Q.front == Q.rear)\n        return true;\n    else\n        return false;\n}\n//(3)入队\nvoid EnQueue(LinkQueue &Q,ElemType x){\n    LinkNode *S =(LinkNode *)malloc(sizeof(LinkNode));\n    s -> data = x;  s -> next =NULL;// 创建新结点，插入到队尾\n    Q.rear -> next = s;\n    Q.rear = s;\n}\n//(4)出队\nbool DeQueue(LinkQueue &Q,ElemType &x){\n    if(Q.front == Q.rear)\n        return false; //空队\n    LinkNode *p = Q.front -> next;\n    x = p -> data;\n    Q.front -> next = p->next;\n    if(Q.rear == p)\n        Q.rear = Q.front;\t//若原队列中只有一个结点，删除后变空\n    free(p);\n    return true;\n}\n```\n\n\n\n#### &emsp;2.4 双端队列\n\n&emsp;&emsp;双端队列是指允许两端都可以进行入队和出队操作的队列，如下所示。其元素的逻辑结构仍是线性结构，将队列的两端分别称为前端和后端，两端都可以入队和出队。\n\n<img src=\"双端队列.jpg\" style=\"zoom:80%;\" />\n\n&emsp;&emsp;在双端队列进队时，前端进的元素排列在队列中后端进的元素的前面，后端进的元素排列在队列中前端进的元素的后面。在双端队列出队时，无论是前端还是后端出队，先出的元素排列在后出的元素的前面。\n\n##### &emsp;&emsp;1.  输出受限的双端队列\n\n&emsp;&emsp;允许在一端进行插入和删除，但在另一端只允许插入的双端队列称为输出受限的双端队列。\n\n##### &emsp;&emsp;2.  输入受限的双端队列\n\n&emsp;&emsp;允许在一端进行插入和删除，但在另一端只允许删除的双端队列称为输入受限的双端队列。若限定双端队列从某个端点插入的元素只能从该端点删除，则该双端队列结蜕变为两个栈底相邻接的栈。\n\n\n\n### 3、数组和特殊矩阵\n\n#### &emsp;3.1 数组的定义\n\n&emsp;&emsp;数组是由n( n≥1 )个相同类型的数据元素构成的有限序列，每个数据元素称为一个数组元素，每个元素在n个线性关系中的序号称为该元素的下标，下标的取值范围称为数组的维界。\n\n&emsp;&emsp;数组与线性表的关系：数组是线性表的推广。一维数组可视为一个线性表；二维数组可视为其元素也是定长线性表的线性表，以此类推。数组一旦被定义，其维数和维界就不再改变。因此，除结构的初始化和销毁外，数组只会有存取元素和修改元素的操作。\n\n\n\n#### &emsp;3.2 数组的存储结构\n\n##### &emsp;&emsp;对于一维数组\n\n&emsp;&emsp;其存储结构关系式如下：\n$$\nLOC(a_{i,j}) = LOC(a_{0,0})+i*L (0≤i<n)\n$$\n&emsp;&emsp;其中，L是每个数组元素所占的存储单元。\n\n\n\n##### &emsp;&emsp;对于多维数组\n\n&emsp;&emsp;有两种映射方式：按行优先和按列优先。\n\n###### &emsp;&emsp;1. 按行优先\n\n&emsp;&emsp;以二维数组为例，按行优先存储的基本思想是：先行后列，先存储行号较小的元素，行号相等先存储列号较小的元素。设二维数组的行下标与列下标的范围分别为[0,h₁]与[0,h₂]，则存储结构关系式为\n$$\nLOC(a_{i,j}) = LOC(a_{0,0})+[i*(h_2+1)+j]*L\n$$\n例如：\n\n<img src=\"按行优先顺序存放.jpg\" style=\"zoom:80%;\" />\n\n###### &emsp;&emsp;2. 按列优先\n\n&emsp;&emsp;当以列优先方式存储时，得出存储结构关系式为\n$$\nLOC(a_{i,j}) = LOC(a_{0,0})+[j*(h_1+1)+i]*L\n$$\n例如：\n\n<img src=\"按列优先顺序存放.jpg\" style=\"zoom:80%;\" />\n\n\n\n#### &emsp;3.3 特殊矩阵的压缩存储\n\n&emsp;&emsp;压缩存储:指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。其目的是节省存储空间。\n\n&emsp;&emsp;特殊矩阵:指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一定规律性的矩阵。常见的特殊矩阵有对称矩阵、上(下)三角矩阵、对角矩阵等。\n\n&emsp;&emsp;特殊矩阵的压缩存储方法:找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。\n\n\n\n#### &emsp;3.4 稀疏矩阵\n\n&emsp;&emsp;矩阵中非零元素的个数 t，相对矩阵元素的个数来说非常少，即s>>t的阵称为稀疏矩阵。例如，一个矩阵的阶为 100x100，但是该矩阵中只有少于 100 个非零元素。\n\n&emsp;&emsp;若采用常规的方法存储稀疏矩阵，则相当浪费存储空间，因此仅存储非零元素。但通常非零元素的分布没有规律，所以仅存储非零元素的值是不够的，还要存储它所在的行和列。因此，将非零元素及其相应的行和列构成一个三元组(行标，列标，值)。然后按照某种规律存储这些三元组。稀疏阵压缩存储后便失去了随机存取特性。\n\n&emsp;&emsp;稀疏矩阵的三元组既可以采用数组存储，也可以采用十字链表法存储。\n","tags":["数据结构"],"categories":["数据结构"]},{"title":"线性表","url":"/2024/01/16/线性表/","content":"\n&emsp;&emsp;本篇是对数据结构线性表的知识梳理与简要总结。\n\n<!--more-->\n\n### 0、知识框架\n\n<img src=\"知识框架.jpg\" style=\"zoom:67%;\" />\n\n\n\n### 1、线性表的定义和基本操作\n\n#### &emsp;1.1 线性表的定义\n\n&emsp;&emsp;**线性表**是具有**相同**数据类型的n( n ≥ 0 ) 个数据元素的**有限序列**，其中n为表长，当n = 0时线性表是一个空表。若用L命名线性表，则其一般表示为\n$$\nL = (a_1,a_2,a_3,……,a_i,a_{i+1},……,a_n)\n$$\n式中，a₁是唯一的“ 第一个 ”数据元素，又称表头元素；an是唯一的一个“ 最后一个 ”数据元素，又称表尾元素。除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素有且仅有一个直接后继（“ 直接前驱 ”和“ 前驱 ”、“ 直接后继 ” 和 “ 后继 ”通常被视为同义词）。以上就是线性表的逻辑特性，这种线性有序的逻辑结构正是线性表的名字的由来。\n\n&emsp;&emsp;由此，我们得出线性表的**特点**如下。\n\n- 表中元素的个数有限。\n- 表中元素具有逻辑上的顺序性，表中元素有其先后次序。\n- 表中元素都是数据元素，每个元素都是单个元素。\n-  表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。\n- 表中元素具有抽象性，即仅讨论元素之间的逻辑关系，而不考虑元素究竟表示什么内容。\n\n&emsp;&emsp;注意：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两者属于不同层面的概念。\n\n\n\n#### &emsp;1.2 线性表的基本操作\n\n&emsp;&emsp;一个数据结构的基本操作是指其最核心、最基本的操作。其他较复杂的操作可通过调用其基本操作来实现。线性表的主要操作如下。\n\n&emsp;&emsp;InitList(&L)：初始化表。构造一个空的线性表。\n\n&emsp;&emsp;Length(L)：求表长。返回线性表L的长度，即L中数据元素的个数。\n\n&emsp;&emsp;LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。\n\n&emsp;&emsp;GetElem(L,i)：按位查找操作。获取表L中第 i 个位置的元素的值。\n\n&emsp;&emsp;ListInsert(&L,i,e)：插入操作。在表L中第 i 个位置插入指定元素e。\n\n&emsp;&emsp;ListDalete(&L,i,e)：删除操作。删除表L中第 i 个位置的元素，并用e返回删除元素的值。\n\n&emsp;&emsp;PrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。\n\n&emsp;&emsp;Empty(L)：判空操作。若L为空表，则返回true，否则返回false。\n\n&emsp;&emsp;DestroyList(&L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。\n\n\n\n### 2、线性表的顺序表示\n\n#### &emsp;2.1 顺序表的定义\n\n&emsp;&emsp;线性表的顺序存储又称**顺序表**。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。第1个元素存储在线性表的起始位置，**第i个元素存储位置后面紧接着存储的是第i+1个元素**，称i为元素ai在线性表中的位序。因此，线性表的特点是**表中元素的逻辑顺序与其物理顺序相同**。\n\n&emsp;&emsp;假设线性表L存储的起始位置为LOC(A)，sizeof(ElemType)是每个数据元素所占用存储空间的大小，则表L所对应的顺序存储如下所示。\n\n![](线性表的顺序存储结构.jpg)\n\n&emsp;&emsp;每个数据元素的存储位置都和线性表的起始位置相差一个和该数据元素的位序成正比的常数，因此，顺序表中的任意一个数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。通常用高级程序设计语言中的数据来描述线性表的顺序存储结构（注意：线性表中元素的位序是从1开始的，而数组中元素的下表是从0开始的）。\n\n&emsp;&emsp;假定线性表的元素类型为ElemType，则线性表的顺序存储类型描述为：\n\n```c\n#define MaxSize 50          //定义线性表的最大长度\ntypedef struct{\n    ElemType data[MaxSize]; //顺序表的元素\n    int length;             //顺序表的当前长度\n}SqList;                    //顺序表的类型定义\n```\n\n&emsp;&emsp;一维数组可以是静态分配的，也可以是动态分配的。在静态分配时，由于数组的大小和空间事先已经固定，一旦空间占满，再加入新的数据就会产生溢出，进而导致程序崩溃。\n\n&emsp;&emsp;而在动态分配时，存储数组的空间是在程序执行过程中通过动态分配语句分配的，一旦数据空间占满，就另外开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储数据空间的目的，而不需要为线性表一次性地划分所有空间。\n\n```c\n#define InitSize 100     //表长度的初始定义\ntypedef struct{\n    ElemType *data;      //指示动态分配数组的指针\n    int MaxSize,length;  //数组的最大容量和当前个数\n}SeqList;                //动态分配数组顺序表的类型定义\n```\n\n&emsp;&emsp;另外，C和C++的初始动态分配语句如下：\n\n```c\nC：\n    L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);\n\nC++:\n\tL.data = new ElemType[InitSize];\n```\n\n&emsp;&emsp;注意：动态分配并不是链式存储，它同样属于顺序存储结构，物理结构没有变化，依然是随机存取方式，只是分配的空间大小可以在运行时动态决定。\n\n&emsp;&emsp;顺序表最主要的特点是随机访问，即通过首地址和元素序号可在时间O(1)内找到指定的元素。\n\n&emsp;&emsp;顺序表的存储密度高，每个结点只存储数据元素。\n\n&emsp;&emsp;顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。\n\n\n\n#### &emsp;2.2 顺序表上基本操作的实现\n\n&emsp;&emsp;这里仅讨论顺序表的插入、删除和按值查找的算法，其他基本操作的算法都比较简单\n\n##### &emsp;&emsp;1. 插入操作\n\n&emsp;&emsp;在顺序表L的第 i (1 <= i <= L.length+1)个位置插入新元素e。若i的输入不合法，则返回false，表示插入失败；否则，将第 i 个元素及其后的所有元素依次往后移动一个位置，腾出一个空位置插入新元素e，顺序表长度增加1，插入成功，返回true。\n\n```c\nbool ListInsert(SqList &L,int i,ElemType e){\n    if(i < 1 || i > L.length + 1)          //判断i的范围是否有效\n        return false;\n    if(L.length >= MaxSize)                //当前存储空间已满，不能插入\n        return false;\n    for(int j = L.length ; j >= i ; j--)   //将第i个元素及之后的元素后移\n        L.data[j] = L.data[j-1];\n    L.data[i-1] = e;                       //在位置i处放入e\n    L.length++;                            //线性表长度加1\n    return true\n}\n```\n\n&emsp;&emsp;最好情况：在表尾插入（即i = n + 1），元素后移语句将不执行，时间复杂度为O(1)。\n\n&emsp;&emsp;最坏情况：在表头插入（即i = 1），元素后移语句将执行n次，时间复杂度为O(n)。\n\n&emsp;&emsp;平均情况：假设pi(pi = 1 / (n+1) )，是在第i个位置上插入一个结点的概率，则在长度为n的线性表中插入一个结点时，所需移动结点的平均次数为：\n$$\n\\sum^{n+1}_{i=1}p_i(n-i+1)=\\sum^{n+1}_{i=1}\\frac{1}{n+1}(n-i+1)=\\frac{1}{n+1}\\sum^{n+1}_{i=1}(n-i+1)=\\frac{1}{n+1}\\frac{n(n+1)}{2}=\\frac{n}{2}\n$$\n&emsp;&emsp;因此，顺序表插入算法的平均时间复杂度为O(n)。\n\n\n\n##### &emsp;&emsp;2. 删除操作\n\n&emsp;&emsp;删除顺序表L中的第 i (1 <= i <= L.length+1)个位置的元素，用引用变量e返回。若i的输入不合法，则返回false；否则，将被删元素赋给引用变量e，并将第i+1个元素及其后的所有元素依次往前移动一个位置，返回true。\n\n```c\nbool ListDelete(SqList &L,int i,Elemtype &e){\n    if(i<1||i>L.length)                  //判断i的范围是否有效\n        return false;\n    e = L.data[i-1];                     //将被删除的元素赋值给e\n    for(int j = i ; j < L.length ; j++)  //将第i个位置的元素前移\n        L.data[j-1] = L.data[j];\n    L.length--;                          //线性表长度减1\n    return true;\n}\n```\n\n&emsp;&emsp;最好情况：删除表尾元素（即 i = n），无须移动元素，时间复杂度为O(1)。\n\n&emsp;&emsp;最坏情况：删除表头元素（即 i = 1），需移动除表头元素外的所有元素，时间复杂度为O(n)。\n\n&emsp;&emsp;平均情况：假设pi（pi = 1 / n）是删除第 i 个位置上结点的概率，则在长度为n的线性表中删除一个结点时，所需移动结点的平均次数为\n$$\n\\sum^n_{n-1}p_i(n-i)=\\sum^n_{i=1}\\frac{1}{n}(n-i)=\\frac{1}{n}\\sum^n_{i=1}(n-i)=\\frac{1}{n}\\frac{n(n-1)}{2}=\\frac{n-1}{2}\n$$\n&emsp;&emsp;因此，顺序表删除算法的平均时间复杂度为O(n)。\n\n&emsp;&emsp;可见，顺序表中插入和删除操作的时间主要耗费在移动元素上，而移动元素的个数取决于插入和删除元素的位置。\n\n\n\n##### &emsp;&emsp;3. 按值查找（顺序查找）\n\n&emsp;&emsp;在顺序表L中查找第一个元素值等于e的元素，并返回其位序。\n\n```c\nint LocateElem(SqList L,ElemType e){\n    int i;\n    for(i = 0; i < L.length ; i++)\n        if(L.data[i] == e)\n            return i + 1;    //下表为i的元素值等于e，返回其位序i+1\n\treturn 0;                //退出循环，说明查找失败\n}\n```\n\n&emsp;&emsp;最好情况：查找的元素就在表头，仅需比较一次，时间复杂度为O(1)。\n\n&emsp;&emsp;最坏情况：查找的元素在表尾（或不存在）时，需要比较n次，时间复杂度为O(n)。\n\n&emsp;&emsp;平均情况：假设pi（pi = 1 / n）是查找的元素在第 i 个位置上结点的概率，则长度为n的线性表中查找值为e的元素所需比较的平均次数为\n$$\n\\sum^n_{i=1}p_i*i=\\sum^n_{i=1}\\frac{1}{n}*i=\\frac{1}{n}\\frac{n(n+1)}{2}=\\frac{n+1}{2}\n$$\n&emsp;&emsp;因此，顺序表按值查找算法的平均时间复杂度为O(n)。\n\n\n\n### 3、线性表的链式表达\n\n&emsp;&emsp;顺序表的存储位置可以用一个简单直观的公式表示，它可以随机存取表中任意一个元素，但插入和删除操作需要移动大量元素。链式存储线性表时，不需要使用地址连续的存储单元，即不要求逻辑上相邻的元素在物理位置上也相邻，它通过“ 链 ”建立起元素之间的逻辑关系，因此插入和删除操作不需要移动元素，而只需要修改指针，但也会失去顺序表可随机存取的优点。\n\n#### &emsp;3.1 单链表的定义\n\n&emsp;&emsp;线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身信息外，还需要存放一个指向其后继的指针。\n\n&emsp;&emsp;单链表中结点类型的描述如下：\n\n```c\ntypedef struct LNode{   //定义单链表结点类型\n    Elemtype data;      //数据域\n    struct Lnode *next; //指针域\n}LNode,*LinkList;\n```\n\n&emsp;&emsp;利用单链表可以解决顺序表需要大量连续存储单元的缺点，但单链表附加指针域，也存在浪费存储空间的缺点。由于单链表的元素离散地分布在存储空间中，所以单链表是非随机存取的存储结构，即不能直接找到表中某个特定的结点。查找某个特点的结点时，需要从表头开始遍历，因此查找。\n\n&emsp;&emsp;通常用头指针来标识一个单链表，如单链表L，头指针NULL时表示一个空表。此外，为了操作上的方便，在单链表第一个结点之前附加一个结点，称为头结点。头结点的数据源可以不设任何信息，也可以记录表长等信息。头结点的指针域指向线性表的第一个元素结点，如下所示：\n\n<img src=\"带头结点的单链表.jpg\" style=\"zoom:90%;\" />\n\n&emsp;&emsp;头结点和头指针的区分：不管带不带头结点，头指针都是始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。\n\n&emsp;&emsp;引入头结点后，可以带来两个优点：\n\n&emsp;&emsp;①由于第一个数据结点的位置被存放头结点的指针域中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。\n\n&emsp;&emsp;②无论链表是否为空，其头指针都是指向头结点的非空指针（空表中头结点的指针域为空），因此空表和非空表的处理也就得到了统一。\n\n\n\n#### &emsp;3.2 单链表上基本操作的实现\n\n##### &emsp;1. 采用头插法建立单链表\n\n&emsp;&emsp;该方法从一个空表开始，生成新的结点，并将读取到的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头，即头结点之后，如下所示：\n\n<img src=\"头插法建立单链表.jpg\" style=\"zoom:100%;\" />\n\n&emsp;&emsp;头插法建立单链表的算法如下：\n\n```c\nLinkList List_HeadInsert(LinkList &L){    //逆向建立单链表\n    LNode *s; int x;\n    L = (LinkList)malloc(sizeof(LNode));  //创建头结点\n    L -> next = NULL;\t\t\t\t\t  //初始为空链表\n    scanf(\"%d\",&x);\t\t\t\t\t\t  //输入结点的值\n    while(x != 9999){\t\t\t\t\t  //输入9999表示结束\n        s = (LNode*)malloc(sizeof(LNode)) //创建新结点\n        s -> data = x;\n        s -> next = L -> next;\n        L -> next = s;\t\t\t\t\t  //将新结点插入表中，L为头指针\n        scanf(\"%d\",&x);\n    }\n    return L;\n}\n```\n\n&emsp;&emsp;采用头插法建立单链表时，读入数据的顺序与生成的链表中的元素的顺序是相反的。每个结点插入的时间为O(1)，设单链表长为n，则总时间复杂度为O(n)。\n\n\n\n##### &emsp;2. 采用尾插法建立单链表\n\n&emsp;&emsp;头插法建立单链表的算法虽然简单，但生成的链表中节点的次序和输入数据的顺序不一致。若希望两者次序一致，则可以采用尾插法。该方法将新结点插入到当前链表的表尾，为此必须增加一个尾指针r，使其始终指向当前链表的尾节点，如下所示：\n\n<img src=\"尾插法建立单链表.jpg\" style=\"zoom:100%;\" />\n\n&emsp;&emsp;尾插法建立单链表的算法如下：\n\n```c\nLinkList List_TailInsert(LinkList &L){     //正向建立单链表\n    int x;\t\t\t\t\t\t\t\t   //设元素类型为整型\n    L = (LinkList)malloc(sizeof(LNode));\n    LNode *s,*r = L;\t\t\t\t\t   //r为表尾指针\n    scanf(\"%d\",&x);\t\t\t\t\t\t   //输入结点的值\n    while(x != 9999){\t\t\t\t\t   //输入9999表示结束\n        s = (LNode*)malloc(sizeof(LNode));\n        s -> data = x;\n        r -> next = s;\n        r = s;\t\t\t\t\t\t\t\t//r指向新的表尾结点\n        scanf(\"%d\",&x);\n    }\n    r -> next = NULL;\t\t\t\t\t\t//尾节点指针置空\n    return L;\n}\n```\n\n&emsp;&emsp;因为附设了一个指向表尾节点的指针，故时间复杂度和头插法相同。\n\n\n\n##### &emsp;3. 按序号查找节点\n\n&emsp;&emsp;在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL。\n\n&emsp;&emsp;按序号查找结点值的算法如下：\n\n```c\nLNode *GetElem(LinkList L,int i){\n    if(i<1)\n        return NULL;\t\t\t//若i无效，则返回NULL\n    int j = 1;\t\t\t\t\t//计数，初始为1\n    LNode *p = L -> next;\t\t//第一个结点指针赋给p\n    while(p != NULL && j < i){\t//从第一个结点开始找，查找第i个结点\n        p = p -> next;\n        j++;\n    }\n    return p;\t\t//返回第i个结点的指针，若i大于表长则返回NULL\n}\n```\n\n&emsp;&emsp;按序号查找操作的时间复杂度为O(n)。\n\n\n\n##### &emsp;4. 按值查找表结点\n\n&emsp;&emsp;从单链表的第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针；若整个单链表中没有这样的结点，则返回NULL。\n\n&emsp;&emsp;按值查找表结点的算法如下：\n\n```c\nLNode *LocateElem(LinkList L,ElemType e){\n    LNode *p = L -> next;\n    while(p != NULL && p -> data != e) //从第i个结点开始查找data域为e的结点\n        p = p->next;\n    return p;   //找到后返回该结点指针，否则返回NULL\n}\n```\n\n&emsp;&emsp;按值查找操作的时间复杂度为O(n)。\n\n\n\n#####  &emsp;5. 插入结点操作\n\n&emsp;&emsp;插入结点操作将值为x的新结点插入到单链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i - 1个结点，再在其后插入新结点。\n\n&emsp;&emsp;算法首先调用按序号查找酸罐GetElem(L,i - 1)，查找第i - 1个结点。假设返回的第i - 1个结点为*p，然后令新结点 *s的指针域指向 *p的后继结点，再令结点 *p的指针域指向新插入的结点 *s。其操作过程如下所示：\n\n<img src=\"单链表的插入操作.jpg\" style=\"zoom:100%;\" />\n\n&emsp;&emsp;实现插入结点的代码片段如下：\n\n```c\np = GetElem(L,i-1);     //查找插入位置的前驱结点\ns -> next = p -> next;  //图中操作步骤1\np -> newxt = s;         //图中操作步骤2\n```\n\n&emsp;&emsp;**算法中，第2、3句顺序不能颠倒**，本算法主要时间开销在于查找第 i - 1个元素，时间复杂度为O(n)。若在给定的结点后面插入新结点，则时间复杂度仅为O(1)。\n\n###### &emsp;&emsp;拓展：对某一结点进行前插操作\n\n&emsp;&emsp;另外，对某一节点进行前插操作时（前插操作是在某结点的前面插入一个新结点，后插操作的定义刚好与之相反，在单链表插入算法中，通常都是采用后插操作），以上面算法为例，首先调用函数GetElem(  )找到第i - 1个结点，即插入结点的前驱结点后，再对其进行后插操作。由此可知，对结点的前插操作均可可转化为后插操作，前提是从单链表的头结点开始顺序查找到其前驱结点，时间复杂度为O(n)。\n\n&emsp;&emsp;此外，可采用另一种方式将其转化为后插操作来实现，设待插入结点为 *s，将 *s插入到 *p的前面。我们仍然将 *s插入到 *p的后面，然后将p->data和s->data交换，这样既满足了逻辑关系，又能将时间复杂度为O(1)。算法的代码片段如下：\n\n```c\n//将*s结点插入到*p之前的主要代码片段\ns -> next = p -> next;\t\t//修改指针域，不能颠倒\np -> next = s;\ntemp = p -> data;\t\t\t//交换数据域部分\np -> data = s -> data;\ns -> data = temp\n```\n\n\n\n##### &emsp;6. 删除结点操作\n\n&emsp;&emsp;删除结点操作是将单链表的第i个结点删除。先检查删除位置的合法性，后查找表中第i -1个结点，即被删结点的前驱结点，再将其删除。其操作过程如下所示：\n\n<img src=\"单链表结点的删除.jpg\" style=\"zoom:100%;\" />\n\n&emsp;&emsp;假设结点 *p为找到的被删结点的前驱结点，为实现这一操作后的逻辑关系变化，仅需修改 *p的指针域，即将 *p的指针域next指向 *q的下一结点。实现删除结点的代码片段如下：\n\n```c\np = GetElem(L,i-1);\t\t//查找删除位置的前驱结点\nq = p -> next;\t\t\t//令q指向被删除结点\np -> next = q -> next;  //将*q结点从链中“断开”\nfree(q);\t\t\t\t//释放结点的存储空间\n```\n\n&emsp;&emsp;和插入算法一样，该算法的主要时间也是耗费在查找操作上，时间复杂度为O(n)。\n\n###### &emsp;&emsp;拓展：删除结点 *p\n\n&emsp;&emsp;要删除某个给定结点 *p，通常的做法是先从链表的头结点开始顺序找到其前驱结点，然后执行删除操作，算法的时间复杂度为O(n)。\n\n&emsp;&emsp;其实，删除结点 *p的操作可用删除 *p的后继结点操作来实现，实质就是将其后继结点的值赋予其自身，然后删除后继结点，也能使得时间复杂度为O(1)。实现上述操作的代码片段如下：\n\n```c\nq = p -> next;\t\t\t\t\t//令q指向*p的后继结点\np -> data = p -> next -> data;  //用后继结点的数据域覆盖\np -> next =q -> next;\t\t\t//将*q结点从链中“断开”\nfree(q);\t\t\t\t\t\t//释放后继结点的存储空间\n```\n\n\n\n##### &emsp;7. 求表长操作\n\n&emsp;&emsp;求表长操作就是计算单链表中数据结点（不含头结点）的个数，需要从第一个结点开始顺序依次访问表中的每个结点，为此需要设置一个计算器变量，每访问一个结点，计数器加1，直到访问到空结点为止。算法的时间复杂度为O(n)。\n\n&emsp;&emsp;需要注意的是，因为单链表的长度是不包括头结点的，因此不带头结点和带头结点的单链表在求表长操作上会略有不同。对不带头结点的单链表，当表为空时，要单独处理。\n\n\n\n#### &emsp;3.3 双链表\n\n&emsp;&emsp;单链表结点中只有一个指向其后继的指针，使得单链表只能从头结点依次顺序地向后遍历。要访问某个结点的前驱结点（插入、删除操作时），只能从头开始遍历，访问后继结点的时间复杂度为O(1)，访问前驱结点的时间复杂度为O(n)。\n\n&emsp;&emsp;为了克服单链表的上述缺点，引入了双链表，双链表结点中有两个指针prior和next，分别指向其前驱结点和后继结点，如下所示：\n\n<img src=\"双链表示意图.jpg\" style=\"zoom:80%;\" />\n\n&emsp;&emsp;双链表中结点类型的描述如下：\n\n```c\ntypedef struct DNode{\t\t\t//定义双链表结点类型\n    ElemType data;\t\t\t\t//数据域\n    struct DNode *prior,*next;\t//前驱和后继指针\n}DNode, *DLinklist;\n```\n\n&emsp;&emsp;双链表在单链表的结点中增加了一个指向其前驱的prior指针，因此双链表中的按值查找和按位查找的操作与单链表的相同。但双链表在插入和删除操作的实现上，与单链表有着较大的不同。这是因为“链”变化时也需要对prior指针做出修改，其关键是保证在修改的过程中不断链。此外，双链表可以很方便地找到其前驱结点，因此，插入、删除操作的时间复杂度仅为O(1)。\n\n##### &emsp;&emsp;1. 双链表的插入操作\n\n&emsp;&emsp;在双链表中p所指的结点之后插入结点 *s，其指针的变化过程如下：\n\n<img src=\"双链表插入结果过程.jpg\" style=\"zoom:90%;\" />\n\n&emsp;&emsp;插入操作的代码片段如下：\n\n```c\ns -> next = p -> next;\t\t//将结点*s插入到结点*p之后\np -> next -> prior = s;\ns -> prior = p;\np -> next = s;\n```\n\n&emsp;&emsp;上述代码的语句顺序不是唯一的，但是也不是任意的，第1、2必须在第4步之前。\n\n\n\n##### &emsp;&emsp;2. 双链表的删除操作\n\n&emsp;&emsp;删除双链表中结点 *p的后继结点 *q，删除操作的代码片段如下：\n\n```c\np -> next = q -> next;\nq -> next -> prior = p;\nfree(q);\n```\n\n\n\n#### &emsp;3.4 循环链表\n\n##### &emsp;&emsp;1. 循环单链表\n\n&emsp;&emsp;循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环，如下：\n\n<img src=\"循环单链表.jpg\" style=\"zoom:80%;\" />\n\n&emsp;&emsp;在循环单链表中，表尾结点 *r 的next域指向L，故表中没有指针域为NULL的结点，因此，循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针。\n\n&emsp;&emsp;循环单链表的插入、删除算法与单链表的几乎一样，所不同的是若操作是在表尾进行，则执行的操作不同，以让单链表继续保持循环的性质。当然，正是因为循环链表是一个“环”，因此在任何一个位置上的插入和删除操作都是等价的，无须判断是否是表尾。\n\n&emsp;&emsp;在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任意一个结点开始遍历整个链表。有时对循环单链表不设头指针而仅设尾指针，以使得操作效率更高。其原因是，若设的是头指针，对在表尾插入元素需要O(n)的时间复杂度，而若设的是尾指针r，r -> next即为头指针，对在表头或表尾插入元素都只需要O(1)的时间复杂度。\n\n\n\n##### &emsp;&emsp;2.  循环双链表\n\n&emsp;&emsp;由循环单链表的定义不难推出循环双链表。不同的是在循环双链表中，头结点的prior指针还要指向表尾结点，如下所示：\n\n<img src=\"循环双链表.jpg\" style=\"zoom:80%;\" />\n\n&emsp;&emsp;在循环双链表L中，某结点 *p为尾结点时，p -> next == L；当循环双链表为空表时，其头结点的prior域和next域都等于L。\n\n\n\n#### &emsp;3.5 静态链表\n\n&emsp;&emsp;静态链表借助数组来描述线性表的链式存储结构，结点也有数据域data和指针域next，与前面所讲的链表中的指针不同的是，这里的指针是结点的相对地址（数组下标），又称游标。和顺序表一样，静态链表也要预先分配一块连续的内存空间。静态链表和单链表的对应关系如下所示：\n\n<img src=\"静态链表存储示意图.jpg\" style=\"zoom:80%;\" />\n\n&emsp;&emsp;静态链表结构类型的描述如下：\n\n```c\n#define MaxSize 50\t\t//静态链表的最大长度\ntypedef struct{\t\t\t//静态链表结构类型的定义\n    ElemType data;\t\t//存储数据元素\n    int next;\t\t\t//下一个元素的数组下标\n}SLinkList[MaxSize];\n```\n\n&emsp;&emsp;静态链表以next == -1 作为其结束的标志。静态链表的插入、删除操作与动态链表的相同，只需要修改指针，而不需要移动元素。\n\n\n\n#### &emsp;3.6 顺序表和链表的比较\n\n##### &emsp;&emsp;1. 存取（读写）方式\n\n&emsp;&emsp;顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素。例如在第i个位置上执行存或取的操作，顺序表仅需要一次访问，而链表则需从表头开始依次访问 i 次。\n\n##### &emsp;&emsp;2. 逻辑结构与物理结构\n\n&emsp;&emsp;采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也是相邻。而采用链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示。\n\n##### &emsp;&emsp;3. 查找、插入和删除操作\n\n&emsp;&emsp;对于按值查找，顺序表无序时，两者的时间复杂度均为O(n)；顺序表有序时，可采用折半查找，此时时间复杂度为O(log₂n)。\n\n&emsp;&emsp;对于按序号查找，顺序表支持随机访问，时间复杂度仅为O(1)。而链表的平均时间复杂度为O(n)。顺序表的插入、删除操作，平均需要移动半个表长的元素。链表的插入、删除操作，只需修改相关结点的指针域即可。由于链表的每个结点都带有指针域，故而存储密度不够大。\n\n##### &emsp;&emsp;4. 空间分配\n\n&emsp;&emsp;顺序存储在静态存储分配情形下，一旦存储空间装满就不能扩充，若再加入新元素，则会出现内存溢出，因此需要预先分配足够大的存储空间。预先分配过大，可能会导致顺序表后部大量闲置；预先分配过小，又会造成溢出。动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且若内存中没有更大块的连续存储空间，则会导致分配失败。链式存储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。\n\n\n\n### 4、在实际中应该怎样选取存储结构呢？\n\n#### &emsp;&emsp;1.基于存储的考虑\n\n&emsp;&emsp;难以估计线性表的长度或存储规模时，不宜采用顺序表；链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。\n\n#### &emsp;&emsp;2.基于运算的考虑\n\n&emsp;&emsp;在顺序表中按序号访问a1的时间复杂度为O(1)，而表按序号访问的时间复杂度为O(n)，因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。\n\n&emsp;&emsp;在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且表较长时，这一点是不应忽视的；在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然后者优于前者。\n\n#### &emsp;&emsp;3.基于环境的考虑\n\n&emsp;&emsp;顺序表容易实现，任何高级语言中都有数组类型:链表的操作是基于指针的，相对来讲，前者实现较为简单，这也是用户考虑的一个因素。\n\n&emsp;&emsp;总之，两种存储结构各有长短，选择哪一种由实际问题的主要因素决定。通常较稳定的线性表选择顺序存储，而频繁进行插入、删除操作的线性表(即动态性较强)宜选择链式存储。\n","tags":["数据结构"],"categories":["数据结构"]},{"title":"绪论","url":"/2024/01/15/绪论/","content":"\n&emsp;&emsp;本篇是对数据结构的基本概念以及算法和算法评价的总结。\n\n<!--more-->\n\n### 0、知识框架\n\n<img src=\"知识框架.jpg\" style=\"zoom:50%;\" />\n\n\n\n### 1、数据结构的基本概念\n\n#### &emsp;1.1  基本概念和术语\n\n##### &emsp;&emsp;1. 数据\n\n&emsp;&emsp;数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号集合。数据是计算机程序加工的原料。\n\n##### &emsp;&emsp;2. 数据元素\n\n&emsp;&emsp;数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。\n\n##### &emsp;&emsp;3. 数据对象\n\n&emsp;&emsp;数据对象是具有相同性质的数据元素的集合，是数据的一个子集。例如，整数数据对象是集合N = {0,±1,±2,…}。\n\n##### &emsp;&emsp;4. 数据类型\n\n&emsp;&emsp;数据类型是一个值的集合和定义在此集合上的一组操作的总称。\n\n&emsp;&emsp;1）**原子类型**。其值不可再分的数据类型。\n\n&emsp;&emsp;2）**结构类型**。其值可以再分解为若干成分（分量）的数据类型。\n\n&emsp;&emsp;3）**抽象数据类型**。抽象数据组织及与之相关的操作。\n\n##### &emsp;&emsp;5.数据结构\n\n&emsp;&emsp;数据结构是相互之间存在一种或多种特定关系的数据元素的集合。在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构(Structure)。**数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。**\n\n&emsp;&emsp;数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。\n\n<img src=\"数据逻辑结构分类图.jpg\" style=\"zoom:50%;\" />\n\n#### &emsp;1.2 数据结构三要素\n\n##### &emsp;&emsp;1. 数据的逻辑结构\n\n&emsp;&emsp;逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的。数据的逻辑结构分为线性结构和非线性结构，线性表是典型的线性结构；集合、树和图是典型的非线性结构。数据的逻辑结构分类如下所示。\n\n\n\n&emsp;&emsp;**集合**。结构中的数据元素之间除 “同属一个集合” 外，别无其他关系。\n\n&emsp;&emsp;**线性结构**。结构中的数据元素之间只存在一对一的关系。\n\n&emsp;&emsp;**树形结构**。结构中的数据元素之间存在一对多的关系。\n\n&emsp;&emsp;**网状结构或图状结构**。结构中的数据之间存在多对多的关系。\n\n##### &emsp;&emsp;2. 数据的存储结构\n\n&emsp;&emsp;存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是用计算机语言实现的逻辑结构，它依赖于计算机语言。数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储。\n\n&emsp;&emsp;1） **顺序存储**。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中。元素之间的关系由存储单元中，元素之间的关系由存储单元的邻接关系来体现。其优点是可以实现随机存取，每个元素占用最少的存储空间；缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。\n\n&emsp;&emsp;2）**链式存储**。不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。其优点是不会出现碎片现象，能充分利用所有存储单元；缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。\n\n&emsp;&emsp;3）**索引存储**。在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）。其优点是检索速度快；缺点是附加的索引表额外占用存储空间。另外，增加和删除数据时也要修改索引表，因而会花费较多的时间。\n\n&emsp;&emsp;4）**散列存储**。根据元素的关键字直接计算出该元素的存储地址，又称哈希(Hash)存储。其优点是检索、增加和删除结点的操作都很快；缺点是若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。\n\n##### &emsp;&emsp;3. 数据的运算\n\n&emsp;&emsp;施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。\n\n\n\n### 2、算法和算法评价\n\n#### &emsp;2.1 算法的基本概念\n\n&emsp;&emsp;算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。此外，一个算法还具有下列5个重要特征：\n\n&emsp;&emsp;1）**有穷性**。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间时间内完成。\n\n&emsp;&emsp;2）**确定性**。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。\n\n&emsp;&emsp;3）**可行性**。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。\n\n&emsp;&emsp;4）**输入**。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。\n\n&emsp;&emsp;5）**输出**。一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。\n\n&emsp;&emsp;通常，设计一个“好”的算法应考虑以下目标：\n\n&emsp;&emsp;1）**正确性**。算法应该能够正确地解决求解问题。\n\n&emsp;&emsp;2）**可读性**。算法应具有良好的可读性，以帮助人们理解。\n\n&emsp;&emsp;3）**健壮性**。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。\n\n&emsp;&emsp;4）**高效率与低存储量需求**。效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题规模相关。\n\n\n\n#### &emsp;2.2 算法效率的度量\n\n&emsp;&emsp;算法效率的度量是通过**时间复杂度**和**空间复杂度**来描述的。\n\n##### &emsp;&emsp;1. 时间复杂度\n\n&emsp;&emsp;一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为T(n)，它是该算法问题规模n的函数，时间复杂度主要分析T(n)的数量级。算法中基本运算（最深层循环内的语句）的频度与T(n)同数量级，因此通常采用算法中基本运算的频度f(n)来分析算法的时间复杂度（取f(n)中随n增长最快的项，将其系数置为1作为时间复杂度的度量。例如，f(n) = an³ + bn² + cn 的时间复杂度为O(n³)）。因此，算法的时间复杂度记为\n$$\nT(n) = O(f(n))\n$$\n式中，O的含义是T(n)的数量级，其严格的数学定义是：若T(n)和f(n)是定义在正整数集合上的两个函数，则存在正常数C和n₀，使得当n≥n₀时，都满足0≤T(n)≤Cf(n)。\n\n&emsp;&emsp;算法的时间复杂度不仅依赖于问题的规模n，也取决于待输入数据的性质（如输入数据元素的初始状态）。例如，在数组A[0...n-1]中，查找给定值k的算法大致如下：\n\n```c\ni = n - 1;\nwhile(i >= 0 && A[i] != k)\n    i--;\nreturn i;\n```\n\n&emsp;&emsp;该算法中语句3（基本运算）的频度不仅与问题规模n有关，而且与输入实例中A的各元素取值及k的取值有关：\n\n&emsp;&emsp;1. 若A中没有与k相等的元素，则语句3的频度f(n) = n。\n\n&emsp;&emsp;2.若A中的最后一个元素等于k，则语句3的频度f(n)是常数0.\n\n&emsp;&emsp;**最坏时间复杂度**是指在最坏的情况下，算法的时间复杂度。\n\n&emsp;&emsp;**平均时间复杂度**是指所有可能输入实例在等概率出现的情况下，算法的期望运行时间。\n\n&emsp;&emsp;**最好时间复杂度**是指在最好情况下，算法的时间复杂度。\n\n&emsp;&emsp;一般<u>总是考虑在最坏的情况下的时间复杂度</u>，以保证算法的运行时间不会比它更长。\n\n&emsp;&emsp;在分析一个程序的时间复杂性时，有以下两条规则：\n\n&emsp;&emsp;a）加法规则\n$$\nT(n) = T₁(n) + T₂(n) = O(f(n))+O(g(n))=O(max(f(n),g(n)))\n$$\n&emsp;&emsp;b）乘法规则\n$$\nT(n) =  T₁(n)*T₂(n) =O(f(n))*O(g(n)) = O(f(n)*g(n))\n$$\n &emsp;&emsp;常见的渐进时间复杂度为\n$$\nO(1) < O(log₂n) < O(n) < O(nlog₂n) <O(n²)<O(n³)<O(2^n)<O(n!)<O(n^n)\n$$\n\n\n##### &emsp;&emsp;2. 空间复杂度\n\n&emsp;&emsp;算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它是问题规模n的函数。记为\n$$\nS(n) = O(g(n))\n$$\n&emsp;&emsp;一个程序在执行时除需要存储空间来存放本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间。若输入数据所占空间只取决于问题本身，和算法无关，则只需分析除输入和程序之外的额外空间。\n\n&emsp;&emsp;算法原地工作是指算法所需的辅助空间为常量，即O(1)。\n\n\n\n### 3、归纳总结\n\n&emsp;&emsp;本章的重点是分析程序的时间复杂度。要掌握分析时间复杂度的方法和步骤。\n\n#### 3.1 循环主题中的变量参与循环条件的判断\n\n&emsp;&emsp;此类题应该找出主体语句中与T(n)成正比的循环变量，将之代入条件中进行计算。例如，\n\n```c\n1、\nint i = 1;\nwhile (i <= n)\n    i = i * 2;\n\n2、\nint y = 5;\nwhile ((y + 1) * (y + 1) < n)\n    y = y + 1;\n```\n\n&emsp;&emsp;例1中，i 乘以2的次数正是主体语句的执行次数t，因此有2^t≤n，取对数之后有t ≤ log₂n，则T(n) = O(log₂n)。\n\n&emsp;&emsp;例2中，y+1的次数恰好与T(n)成正比，记t为该程序的执行次数，并令t = y - 5，有y = t + 5，\n$$\n(t + 5 + 1)*(t + 5 + 1)<n\n$$\n得 t < √n - 6，即T(n) = O(√n)。\n\n\n\n#### 3.2 循环主体中变量与循环条件无关\n\n&emsp;&emsp;此类题可采用数学归纳法或直接累计循环次数。多层循环时，从内到外分析，忽略单步语句、条件判断语句，只关注主体语句的执行次数。\n\n&emsp;&emsp;此类问题又可分为递归程序和非递归程序：\n\n##### &emsp;1 递归程序\n\n&emsp;&emsp;一般使用公式进行递推。\n\n##### &emsp;2 非递归程序\n\n&emsp;&emsp;可以直接累计次数。\n","tags":["数据结构"],"categories":["数据结构"]},{"title":"基于mediapipe的姿态识别和简单行为识别","url":"/2023/12/07/基于mediapipe的姿态识别和简单行为识别/","content":"&emsp;&emsp;本文是基于mediapipe的姿态识别和简单行为识别，通过对人体姿态关键点的坐标的使用，实现简单的举手检测，其行为检测的精度主要取决于mediapipe关键点的检测精度。\n<!--more-->\n\n## 一、mediapipe的安装\n\n&emsp;&emsp;以Pycharm为例，直接在终端里面输入指令\n\n> pip install  mediapipe\n\n&emsp;&emsp;等待下载完毕即可\n\n\n\n## 二、使用mediapipe检测关键点\n\n### 1.mediapipe的介绍\n\n   &emsp;&emsp;Mediapipe是一个用于构建机器学习管道的框架，用户处理视频、音频等时间序列数据。这个跨平台框架使用于桌面/服务器、Android、ios和各类嵌入式设备。\n\n   &emsp;&emsp;目前mediapipe包含以下16个solution，总的来说，mediapipe是一个很好的库，可以解决ML项目中面临的大部分麻烦，而且很适合做行为识别方向练手使用。\n\n   > 1.人脸检测\n   >\n   > 2.Face Mesh\n   >\n   > 3.虹膜\n   >\n   > 4.手\n   >\n   > 5.姿态\n   >\n   > 6.人体\n   >\n   > 7.人物分割\n   >\n   > 8.头发分割\n   >\n   > 9.目标检测\n   >\n   > 10.Box Tracking\n   >\n   > 11.instant Motion Tracking\n   >\n   > 12.3D目标检测\n   >\n   > 13.特征匹配\n   >\n   > 14.AutoFlip\n   >\n   > 15.MediaSequence\n   >\n   > 16.YouTuBe_8M\n\n### 2.使用mediapipe检测人体\n\n&emsp;&emsp;这里仅使用mediapipe关于人体识别的方法（solution），谷歌官方将这种人体姿态识别的方法叫做Blazepose。\n\n#### （1） 检测前的准备工作\n\n```python\n   '''导入一些基本的库'''\n   import cv2\n   import mediapipe as mp\n   import time\n   from tqdm import tqdm\n   import numpy as np\n   from PIL import Image, ImageFont, ImageDraw\n   # ------------------------------------------------\n   #   mediapipe的初始化\n   # \t这一步是必须的，因为要使用到以下定义的几个类\n   #   具体的函数参数意义可以参考第三方资料\n   # ------------------------------------------------\n   mp_pose = mp.solutions.pose\n   mp_drawing = mp.solutions.drawing_utils\n   pose = mp_pose.Pose(static_image_mode=True)\n   \n```\n\n#### （2）检测图片\n\n```python\n   def process_frame(img):\n       start_time = time.time()\n       h, w = img.shape[0], img.shape[1] # 高和宽\n       # 调整字体\n       tl = round(0.005 * (img.shape[0] + img.shape[1]) / 2) + 1\n       tf = max(tl-1, 1)\n       # BRG-->RGB\n       img_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n       # 将RGB图像输入模型，获取 关键点 预测结果\n       results = pose.process(img_RGB)\n       keypoints = ['' for i in range(33)]\n       if results.pose_landmarks:\n           mp_drawing.draw_landmarks(img, results.pose_landmarks, mp_pose.POSE_CONNECTIONS)\n           for i in range(33):\n               cx = int(results.pose_landmarks.landmark[i].x * w)\n               cy = int(results.pose_landmarks.landmark[i].y * h)\n               keypoints[i] = (cx, cy)\n               # 得到最终的33个关键点\n       else:\n           print(\"NO PERSON\")\n           struction = \"NO PERSON\"\n           img = cv2.putText(img, struction, (25, 100), cv2.FONT_HERSHEY_SIMPLEX, 1.25, (255, 255, 0),\n                             6)\n       end_time = time.time()\n       process_time = end_time - start_time\n       # 图片关键点预测时间\n       fps = 1 / process_time\n       # 帧率\n       colors = [[random.randint(0,255) for _ in range(3)] for _ in range(33)]\n       radius = [random.randint(8,15) for _ in range(33)]\n       for i in range(33):\n           cx, cy = keypoints[i]\n           #if i in range(33):\n           img = cv2.circle(img, (cx, cy), radius[i], colors[i], -1)\n       '''str_pose = get_pos(keypoints)#获取姿态\n       cv2.putText(img, \"POSE-{}\".format(str_pose), (12, 100), cv2.FONT_HERSHEY_TRIPLEX,\n                   tl / 3, (255, 0, 0), thickness=tf)'''\n       cv2.putText(img, \"FPS-{}\".format(str(int(fps))), (12, 100), cv2.FONT_HERSHEY_SIMPLEX,\n                   tl/3, (255, 255, 0),thickness=tf)\n       return img\n   \n```\n\n  &emsp;&emsp; 如果需要执行代码，则加入主函数使用\n\n```python\n   if __name__ == '__main__':\n   \timg0 = cv2.imread(\"./data/outImage--20.jpg\")\n       image = cv2.imdecode(np.fromfile(image_path, dtype=np.uint8), -1)\n       img = image.copy()\n       image = process_frame(img)\n       # 使用matplotlib画图    \n       fig, axes = plt.subplots(nrows=1, ncols=2)\n       axes[0].imshow(img0[:,:,::-1])\n       axes[0].set_title(\"原图\")\n       axes[1].imshow(image[:,:,::-1])\n       axes[1].set_title(\"检测并可视化后的图片\")\n       plt.rcParams[\"font.sans-serif\"] = ['SimHei']\n       plt.rcParams[\"axes.unicode_minus\"] = False\n       plt.show()\n       fig.savefig(\"./data/out.png\")\n   \n```\n\n#### （3）检测视频\n\n&emsp;&emsp;任何不涉及3D卷积的机器视觉方法，检测视频其实就是检测图片，因为视频是由多帧图片融合得来的。比如说一个30帧的视频，那么它的每一秒钟，就是由30张图片叠加而成。将这些分割出的图片分别进行检测，最后将检测的图片进行融合，得到的就是检测后的视频。有了这个依据，我们就可以把图片检测过程写成一个函数，在视频的每一帧中调用这个函数就可以了。\n\n&emsp;&emsp;一般使用OpenCV库将视频分解为图片帧的形式，示例代码如下：\n\n```python\ndef video2image(videoPath=\"./video/demo1.mp4\",\n                image_dir=\"./image\"):\n    '''videoPath是视频路径， image_dir是图片保存的文件夹路径'''\n    cap = cv2.VideoCapture(videoPath)\n    frame_count = 0\n    while(cap.isOpened()):\n        success,frame = cap.read()\n        if not success:\n            break\n        frame_count += 1\n    print(\"视频总帧数：\", frame_count)\n    cap.release()\n    cap = cv2.VideoCapture(videoPath)\n    count = 0\n    with tqdm(total=frame_count-1) as pbar:\n        try:\n            while(cap.isOpened()):\n                success, frame = cap.read()\n                if not success:\n                    break\n                #处理帧\n                try:\n                    if count % 20 == 0:\n                        cv2.imwrite(\"{}/outImage--{}.jpg\".format(image_dir, count), frame)\n                except:\n                    print(\"error\")\n                    pass\n                if success == True:\n                    pbar.update(1)\n                    count+=1\n        except:\n            print(\"中途中断\")\n            pass\n    cv2.destroyAllWindows()\n    cap.release()\n    print(\"视频已经处理结束，进行下一步操作！！！\")\n\n```\n\n&emsp;&emsp;那么落实到本文想要实现的功能上，就可以在视频分解出的帧后面加上图片检测函数。\n代码如下所示：\n\n```python\ndef process_video(video_path=\"./Data.mp4\"):\n    video_flag = False\n    cap = cv2.VideoCapture(video_path)\n    out_path = \"./out_Data.mp4\"\n    print(\"视频开始处理……\")\n    frame_count = 0\n    while (cap.isOpened()):\n        success, frame = cap.read()\n        frame_count += 1\n        if not success:\n            break\n    cap.release()\n    print(\"总帧数 = \", frame_count)\n    cap = cv2.VideoCapture(video_path)\n    if video_flag == False:\n        frame_size = cap.get(cv2.CAP_PROP_FRAME_WIDTH), cap.get(cv2.CAP_PROP_FRAME_HEIGHT)\n        #处理图像的尺寸。\n        fourcc = cv2.VideoWriter_fourcc(*'mp4v')\n        #保存视频文件的格式为mp4\n        fps = cap.get(cv2.CAP_PROP_FPS)\n        out = cv2.VideoWriter(out_path, fourcc, fps, (int(frame_size[0]),int(frame_size[1])), )\n        #输出图像的句柄\n    with tqdm(total=frame_count-1) as pbar:\n        try:\n            while cap.isOpened():\n                success, frame = cap.read()\n                if success:\n                    pbar.update(1)\n                    frame = process_frame(frame)\n                    # frame就是视频截取的帧，process_frame表示对其检测。\n                    cv2.namedWindow(\"frame\", cv2.WINDOW_NORMAL)\n                    cv2.imshow(\"frame\", frame)\n                    out.write(frame)\n                    if cv2.waitKey(1) == 27:\n                        break\n                else:\n                    break\n        except:\n            print(\"中途中断\")\n            pass\n    cap.release()\n    cv2.destroyAllWindows()\n    out.release()\n    print(\"视频已保存至\", out_path)\n\n```\n\n## 三、使用mediapipe-BlazePose检测自定义简单行为\n\n### 1.原理介绍\n\n&emsp;&emsp;将mediapipe用于行为检测是比较复杂的一件事；如果这样做，那么行为检测的精度完全取决于mediapipe关键点的检测精度，于是，可以根据下图中人的关节夹角来对人的姿势进行检测。\n\n<img src=\"人体关键点.jpg\" alt=\"人体关键点\" style=\"zoom:67%;\" />\n\n&emsp;&emsp;如举手的时候，手腕的15、16点应该是略高于0点，并且手臂于水平方向夹角一定是在80度到100度之间，那么这样就可以完成对举手动作的简单分类。\n\n### 2.实现过程\n\n&emsp;&emsp;首先要知道，由坐标求得矢量的公式，其实就是两个坐标相减。\n\n&emsp;&emsp;如已知三点P0(x0,y0)、P1(x1,y1)和P2(x2,y2)，那么求P0P1和P0P2两个矢量之间的夹角公式,用代码描写如下：\n\n```python\nv1 = (x1, y1) - (x2, y2)\nv2 = (x0, y0) - (x2, y2)\ndef get_angle(v1, v2):\n    angle = np.dot(v1, v2) / (np.sqrt(np.sum(v1 * v1)) * np.sqrt(np.sum(v2 * v2)))\n    angle = np.arccos(angle) / 3.14 * 180\n\n    cross = v2[0] * v1[1] - v2[1] * v1[0]\n    if cross < 0:\n        angle = - angle\n    return angle\n\n```\n\n&emsp;&emsp;这样就可以得到两个矢量的夹角。\n\n&emsp;&emsp;之后就可以通过夹角对行为进行判断，这里的规则是：\n\n```python\ndef get_pos(keypoints):\n    str_pose = \"\"\n    # 计算左臂与水平方向的夹角\n    keypoints = np.array(keypoints)\n    p_x_right, p_y_right = keypoints[16]\n    p_x_left, p_y_left = keypoints[15]\n    p_x_right_body, p_y_right_body = keypoints[11]\n    p_x_left_body, p_y_left_body = keypoints[12]\n\n    if p_y_right < p_y_right_body:\n        v1 = keypoints[14] - keypoints[16]\n        v2 = keypoints[12] - keypoints[11]\n        get_right_arm = abs(get_angle(v1, v2))\n        # print(\"R{}\".format(get_right_arm))\n        if 60 < get_right_arm < 120:\n            str_pose = \"RIGHT RAISE\"\n    elif p_y_left < p_y_left_body:\n        v1 = keypoints[13] - keypoints[15]\n        v2 = keypoints[11] - keypoints[12]\n        get_left_arm = abs(get_angle(v1, v2))\n        # print(\"L{}\".format(get_left_arm))\n        if 60 < get_left_arm < 120:\n            str_pose = \"LEFT RAISE\"\n    else:\n        str_pose = \"NO RAISE\"\n\n    return str_pose\n    \n```\n\n&emsp;&emsp;得到的str_pose就是行为字符串，在process_frame中可以得到可视化结果。\n\n## 四、总结和一些结果展示\n\n&emsp;&emsp;到这里，关键点检测与简单行为检测就已经全部结束了，这里是把基于tkinter的UI设计与mediapipe进行融合，实现可视化的交互过程，具体代码可以看[github](https://github.com/LiuHongjie1/-mediapipe-.git)。\n\n&emsp;&emsp;以下是一些样例 ~~感谢我的室友~~。\n\n\n\n<img src=\"no raise.jpg\" alt=\"no raise\" style=\"zoom:67%;\" />\n\n<img src=\"left raise.jpg\" alt=\"left raise\" style=\"zoom:67%;\" />\n\n<img src=\"right raise.jpg\" alt=\"right raise\" style=\"zoom:67%;\" />\n\n\n\n\n\n2023年12月15日修改：增加视频检测，修改部分代码\n\n2023年12月25日修改：修改可视化窗口，优化部分代码\n","tags":["Python","机器学习"],"categories":["机器学习"]},{"title":"空想家","url":"/2023/12/07/空想家/","content":"\n&emsp;&emsp;**学计算机一定要有一个非常强大的心理状态：计算机的所有东西都是人做出来的，别人能想出来的，我也一定能想得出来。**\n\n&emsp;&emsp;**在计算机里头，没有任何黑魔法。所有的东西，只不过是我现在不知道而已，总有一天，我会把所有的细节、所有的内部的东西，全都搞明白的。**\n\n"}]