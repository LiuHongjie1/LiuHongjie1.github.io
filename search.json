[{"title":"数据结构绪论","url":"/2024/01/15/数据结构绪论/","content":"\n&emsp;&emsp;数据结构绪论，本篇是对数据结构的基本概念以及算法和算法评价的总结。\n\n<!--more-->\n\n### 零、知识框架\n\n<img src=\"知识框架.jpg\" style=\"zoom:50%;\" />\n\n\n\n### 一、数据结构的基本概念\n\n#### &emsp;1.1  基本概念和术语\n\n##### &emsp;&emsp;1. 数据\n\n&emsp;&emsp;数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号集合。数据是计算机程序加工的原料。\n\n##### &emsp;&emsp;2. 数据元素\n\n&emsp;&emsp;数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。\n\n##### &emsp;&emsp;3. 数据对象\n\n&emsp;&emsp;数据对象是具有相同性质的数据元素的集合，是数据的一个子集。例如，整数数据对象是集合N = {0,±1,±2,…}。\n\n##### &emsp;&emsp;4. 数据类型\n\n&emsp;&emsp;数据类型是一个值的集合和定义在此集合上的一组操作的总称。\n\n&emsp;&emsp;1）**原子类型**。其值不可再分的数据类型。\n\n&emsp;&emsp;2）**结构类型**。其值可以再分解为若干成分（分量）的数据类型。\n\n&emsp;&emsp;3）**抽象数据类型**。抽象数据组织及与之相关的操作。\n\n##### &emsp;&emsp;5.数据结构\n\n&emsp;&emsp;数据结构是相互之间存在一种或多种特定关系的数据元素的集合。在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构(Structure)。**数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。**\n\n&emsp;&emsp;数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。\n\n\n\n#### &emsp;1.2数据结构三要素\n\n##### &emsp;&emsp;1. 数据的逻辑结构\n\n&emsp;&emsp;逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的。数据的逻辑结构分为线性结构和非线性结构，线性表是典型的线性结构；集合、树和图是典型的非线性结构。数据的逻辑结构分类如下所示。\n\n<img src=\"数据逻辑结构分类图.jpg\" style=\"zoom:50%;\" />\n\n&emsp;&emsp;**集合**。结构中的数据元素之间除 “同属一个集合” 外，别无其他关系。\n\n&emsp;&emsp;**线性结构**。结构中的数据元素之间只存在一对一的关系。\n\n&emsp;&emsp;**树形结构**。结构中的数据元素之间存在一对多的关系。\n\n&emsp;&emsp;**网状结构或图状结构**。结构中的数据之间存在多对多的关系。\n\n##### &emsp;&emsp;2. 数据的存储结构\n\n&emsp;&emsp;存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是用计算机语言实现的逻辑结构，它依赖于计算机语言。数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储。\n\n&emsp;&emsp;1） **顺序存储**。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中。元素之间的关系由存储单元中，元素之间的关系由存储单元的邻接关系来体现。其优点是可以实现随机存取，每个元素占用最少的存储空间；缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。\n\n&emsp;&emsp;2）**链式存储**。不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。其优点是不会出现碎片现象，能充分利用所有存储单元；缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。\n\n&emsp;&emsp;3）**索引存储**。在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）。其优点是检索速度快；缺点是附加的索引表额外占用存储空间。另外，增加和删除数据时也要修改索引表，因而会花费较多的时间。\n\n&emsp;&emsp;4）**散列存储**。根据元素的关键字直接计算出该元素的存储地址，又称哈希(Hash)存储。其优点是检索、增加和删除结点的操作都很快；缺点是若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。\n\n##### &emsp;&emsp;3. 数据的运算\n\n&emsp;&emsp;施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。\n\n\n\n#### &emsp;1.3测试\n\n##### &emsp;&emsp;1.单项选择\n\n&emsp;&emsp;01.  可以使用（&emsp;）定义一个完整的数据结构。\n\n&emsp;&emsp;A. 数据元素\n\n&emsp;&emsp;B. 数据对象\n\n&emsp;&emsp;C.数据关系\n\n&emsp;&emsp;D.抽象数据类型\n\n&emsp;&emsp;02.  以下数据结构中，（&emsp;）是非线性数据结构。\n\n&emsp;&emsp;A.树\n\n&emsp;&emsp;B.字符串\n\n&emsp;&emsp;C.队列\n\n&emsp;&emsp;D.栈\n\n&emsp;&emsp;03.以下属于逻辑结构的是（&emsp;）。\n\n&emsp;&emsp;A.顺序表\n\n&emsp;&emsp;B.哈希表\n\n&emsp;&emsp;C.有序表\n\n&emsp;&emsp;D.单链表\n\n&emsp;&emsp;04.以下与数据的存储结构无关的术语是（&emsp;）。\n\n&emsp;&emsp;A.循环队列\n\n&emsp;&emsp;B.链表\n\n&emsp;&emsp;C.哈希表\n\n&emsp;&emsp;D.栈\n\n&emsp;&emsp;05.以下关于数据结构的说法中，正确的是（&emsp;）。\n\n&emsp;&emsp;A.数据的逻辑结构独立于其存储结构\n\n&emsp;&emsp;B.数据的存储结构独立于其逻辑结构\n\n&emsp;&emsp;C.数据的逻辑结构唯一决定其存储结构\n\n&emsp;&emsp;D.数据结构仅由其逻辑结构和存储结构决定\n\n&emsp;&emsp;06.在存储数据时，通常不仅要存储各数据元素的值，而且要储存（&emsp;）。\n\n&emsp;&emsp;A.数据的操作方法\n\n&emsp;&emsp;B.数据元素的类型\n\n&emsp;&emsp;C.数据元素之间的关系\n\n&emsp;&emsp;D.数据的存取方法\n\n&emsp;&emsp;07.链式存储设计时，结点内的存储单元地址（&emsp;）。\n\n&emsp;&emsp;A.一定连续\n\n&emsp;&emsp;B.一定不连续\n\n&emsp;&emsp;C.不一定连续\n\n&emsp;&emsp;D.部分连续，部分不连续\n\n##### &emsp;&emsp;2.综合应用\n\n&emsp;&emsp;01.对于两种不同的数据结构，逻辑结构或物理结构一定不相同吗？\n\n&emsp;&emsp;02.试举一例，说明对相同的逻辑结构，同一种运算在不同的存储方式下实现时，其运算效率不同。\n\n\n\n#### &emsp;1.4.测试答案\n\n##### &emsp;&emsp;1.单项选择\n\n&emsp;&emsp;01. D\n\n&emsp;&emsp;抽象数据类型（ADT）描述了数据的逻辑结构和抽象运算，通常用（数据对象，数据关系，基本操作集）这样的三元组来表示，从而构成一个完整的数据结构定义。\n\n&emsp;&emsp;02. A\n\n&emsp;&emsp;树和图是典型的非线性数据结构，其他选项都属于线性数据结构。\n\n&emsp;&emsp;03. C\n\n&emsp;&emsp;顺序表、哈希表和单链表是三种不同的数据结构，即描述逻辑结构，又描述存储结构和数据运算。而有序表是指关键字有序的线性表，仅描述元素之间的逻辑关系，它既可以链式存储，又可以顺序存储，故属于逻辑结构。\n\n&emsp;&emsp;04. D\n\n&emsp;&emsp;数据的存储结构有顺序存储、链式存储、索引存储和散列存储。循环队列是用顺序表表示的队列，是一种数据结构。栈是一种抽象数据类型，可采用顺序存储或链式存储，只表示逻辑结构。\n\n&emsp;&emsp;05. A\n\n&emsp;&emsp;数据的逻辑结构是从面向实际的问题角度出发的，只采用抽象表达方式，独立于存储结构，数据的存储方式有多种不同的选择；而数据的存储结构是逻辑结构在计算机上的映射，它不能独立于逻辑结构而存在。数据结构包括三个要素，缺一不可。\n\n&emsp;&emsp;06. C\n\n&emsp;&emsp;在存储数据时，不仅要存储数据元素的值，而且要存储数据元素之间的关系。\n\n&emsp;&emsp;07. A\n\n&emsp;&emsp;链式存储设计时，各个不同结点的存储空间可以不连续，但结点内的存储单元地址必须连续。\n\n##### &emsp;&emsp;2.综合应用\n\n&emsp;&emsp;01. 应该注意到，数据的运算也是数据结构的一个重要方面。\n\n&emsp;&emsp;对于两种不同的数据结构，它们的逻辑结构和物理结构完全有可能相同。比如二叉树和二叉排序树，二叉排序树可以采用二叉树的逻辑表示和存储方式，前者通常用于表示层次关系，而后者通常用于排序和查找。虽然它们的运算都有建立树、插入结点、删除结点和查找结点等功能，但对于二叉树和二叉排序树，这些运算的定义是不同的，以查找结点为例，二叉树的时间复杂度为O(n)，而二叉排序树的时间复杂度为O(log₂n)。\n\n&emsp;&emsp;02. 线性表既可以用顺序存储方式实现，又可以用链式存储方式实现。在顺序存储方式下，在线性表中插入和删除元素，平均要移动近一半的元素，时间复杂度为O(n)；而在链式存储方式下，插入和删除的时间复杂度都是O(1)。\n\n\n\n\n\n### 二、算法和算法评价\n\n#### &emsp;2.1 算法的基本概念\n\n&emsp;&emsp;算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。此外，一个算法还具有下列5个重要特征：\n\n&emsp;&emsp;1）**有穷性**。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间时间内完成。\n\n&emsp;&emsp;2）**确定性**。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。\n\n&emsp;&emsp;3）**可行性**。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。\n\n&emsp;&emsp;4）**输入**。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。\n\n&emsp;&emsp;5）**输出**。一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。\n\n&emsp;&emsp;通常，设计一个“好”的算法应考虑以下目标：\n\n&emsp;&emsp;1）**正确性**。算法应该能够正确地解决求解问题。\n\n&emsp;&emsp;2）**可读性**。算法应具有良好的可读性，以帮助人们理解。\n\n&emsp;&emsp;3）**健壮性**。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。\n\n&emsp;&emsp;4）**高效率与低存储量需求**。效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题规模相关。\n\n\n\n#### &emsp;2.2算法效率的度量\n\n&emsp;&emsp;算法效率的度量是通过**时间复杂度**和**空间复杂度**来描述的。\n\n##### &emsp;&emsp;1. 时间复杂度\n\n&emsp;&emsp;一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为T(n)，它是该算法问题规模n的函数，时间复杂度主要分析T(n)的数量级。算法中基本运算（最深层循环内的语句）的频度与T(n)同数量级，因此通常采用算法中基本运算的频度f(n)来分析算法的时间复杂度（取f(n)中随n增长最快的项，将其系数置为1作为时间复杂度的度量。例如，f(n) = an³ + bn² + cn 的时间复杂度为O(n³)）。因此，算法的时间复杂度记为\n$$\nT(n) = O(f(n))\n$$\n式中，O的含义是T(n)的数量级，其严格的数学定义是：若T(n)和f(n)是定义在正整数集合上的两个函数，则存在正常数C和n₀，使得当n≥n₀时，都满足0≤T(n)≤Cf(n)。\n\n&emsp;&emsp;算法的时间复杂度不仅依赖于问题的规模n，也取决于待输入数据的性质（如输入数据元素的初始状态）。例如，在数组A[0...n-1]中，查找给定值k的算法大致如下：\n\n```c\ni = n - 1;\nwhile(i >= 0 && A[i] != k)\n    i--;\nreturn i;\n```\n\n&emsp;&emsp;该算法中语句3（基本运算）的频度不仅与问题规模n有关，而且与输入实例中A的各元素取值及k的取值有关：\n\n&emsp;&emsp;1. 若A中没有与k相等的元素，则语句3的频度f(n) = n。\n\n&emsp;&emsp;2.若A中的最后一个元素等于k，则语句3的频度f(n)是常数0.\n\n&emsp;&emsp;**最坏时间复杂度**是指在最坏的情况下，算法的时间复杂度。\n\n&emsp;&emsp;**平均时间复杂度**是指所有可能输入实例在等概率出现的情况下，算法的期望运行时间。\n\n&emsp;&emsp;**最好时间复杂度**是指在最好情况下，算法的时间复杂度。\n\n&emsp;&emsp;一般<u>总是考虑在最坏的情况下的时间复杂度</u>，以保证算法的运行时间不会比它更长。\n\n&emsp;&emsp;在分析一个程序的时间复杂性时，有以下两条规则：\n\n&emsp;&emsp;a）加法规则\n$$\nT(n) = T₁(n) + T₂(n) = O(f(n))+O(g(n))=O(max(f(n),g(n)))\n$$\n&emsp;&emsp;b）乘法规则\n$$\nT(n) =  T₁(n)*T₂(n) =O(f(n))*O(g(n)) = O(f(n)*g(n))\n$$\n &emsp;&emsp;常见的渐进时间复杂度为\n$$\nO(1) < O(log₂n) < O(n) < O(nlog₂n) <O(n²)<O(n³)<O(2^n)<O(n!)<O(n^n)\n$$\n\n\n##### &emsp;&emsp;2.空间复杂度\n\n&emsp;&emsp;算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它是问题规模n的函数。记为\n$$\nS(n) = O(g(n))\n$$\n&emsp;&emsp;一个程序在执行时除需要存储空间来存放本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间。若输入数据所占空间只取决于问题本身，和算法无关，则只需分析除输入和程序之外的额外空间。\n\n&emsp;&emsp;算法原地工作是指算法所需的辅助空间为常量，即O(1)。\n\n\n\n#### &emsp;2.3测试\n\n##### &emsp;&emsp;1.单项选择\n\n&emsp;&emsp;01. 一个算法应该是（&emsp;）。\n\n&emsp;&emsp;A. 程序\n\n&emsp;&emsp;B. 问题求解步骤的描述\n\n&emsp;&emsp;C. 要满足五个基本特性\n\n&emsp;&emsp;D. A和C\n\n&emsp;&emsp;02. 某算法的时间复杂度为O(n²),表明该算法的（&emsp;）。\n\n&emsp;&emsp;A. 问题规模是n²\n\n&emsp;&emsp;B. 执行时间等于n²\n\n&emsp;&emsp;C. 执行时间与n²成正比\n\n&emsp;&emsp;D. 问题规模与n²成正比\n\n&emsp;&emsp;03. 以下算法的时间复杂度为（&emsp;）。\n\n```c\nvoid fun(int n){\n    int i = 1 ;\n    while(i <= n)\n        i = i * 2;\n}\n```\n\n&emsp;&emsp;A. O(n)\n\n&emsp;&emsp;B. O(n²)\n\n&emsp;&emsp;C. O(nlog₂n)\n\n&emsp;&emsp;D. O(log₂n)\n\n&emsp;&emsp;04. 有以下算法，其时间复杂度为（&emsp;）。\n\n```c\nvoid fun(int n){\n    int i = 0;\n    while(i * i * i <= n)\n    {\n        i++;\n    }\n}\n```\n\n&emsp;&emsp;A. O(n)\n\n&emsp;&emsp;B. O(nlogn)\n\n&emsp;&emsp;C.O(³√n)\n\n&emsp;&emsp;D. O(√n)\n\n&emsp;&emsp;05. 程序段如下：\n\n```c\nfor(i = n - 1 ; i > 1 ; i++)\n    for(j = 1 ; j < i : j++)\n        if(A[j] > A[j + 1])\n            A[j]与A[j + 1]对换；\n```\n\n&emsp;&emsp;其中n是正整数，则最后一行语句的频度在最坏的情况下是（&emsp;）。\n\n&emsp;&emsp;A. O(n)\n\n&emsp;&emsp;B. O(nlogn)\n\n&emsp;&emsp;C.O(n³) \n\n&emsp;&emsp;D. O(n²)\n\n&emsp;&emsp;06. 以下算法中加注释部分的语句执行次数为（&emsp;）。\n\n```c\nint m = 0, i ,j;\nfor(i = 1 ; i <= n :i++)\n    for(j = 1 ; j <= 2 * i ; j++)\n        m++; //本句\n```\n\n&emsp;&emsp;A. n(n+1)\n\n&emsp;&emsp;B. n\n\n&emsp;&emsp;C. n+1\n\n&emsp;&emsp;D.n²\n\n&emsp;&emsp;07. 设n是描述问题规模的非负整数，下面的程序片段的时间复杂度是（&emsp;）。\n\n```c\nx = 2;\nwhile (x < n/2)\nx = x * 2\n```\n\n&emsp;&emsp;A. O(log₂n)\n\n&emsp;&emsp;B. O(n)\n\n&emsp;&emsp;C. O(nlog₂n) \n\n&emsp;&emsp;D. O(n²)\n\n&emsp;&emsp;08. 求整数n(n≥0)的阶乘的算法如下，其时间复杂度是（&emsp;）。\n\n```c\nint fact(int n){\n    if (n <= 1) return 1;\n    return n * fact(n - 1);\n}\n```\n\n&emsp;&emsp;A. O(log₂n)\n\n&emsp;&emsp;B. O(n)\n\n&emsp;&emsp;C. O(nlog₂n) \n\n&emsp;&emsp;D. O(n²)\n\n&emsp;&emsp;09. 已知两个长度分别为m和n的升序链表，若将它们合并为长度为m+n的一个降序链表，则最坏情况下的时间复杂度是（&emsp;）。\n\n&emsp;&emsp;A. O(n)\n\n &emsp;&emsp;B. O(mn)\n\n&emsp;&emsp;C. O(min(m,n))\n\n&emsp;&emsp;D. O(max(m,n))\n\n&emsp;&emsp;10. 下列程序段的时间复杂度是（&emsp;）。\n\n```C\ncount = 0;\nfor (k = 1 ; k <= n ; k*=2)\n    for(j = 1 ; j <= n ; j++)\n        count++;\n```\n\n&emsp;&emsp;A. O(log₂n)\n\n&emsp;&emsp;B. O(n)\n\n&emsp;&emsp;C. O(nlog₂n)\n\n&emsp;&emsp;D. O(n²)\n\n&emsp;&emsp;11. 下列函数的时间复杂度是（&emsp;）。\n\n```c\nint func(int n){\n    int i = 0, sum = 0;\n    while(sum < n)  sum += ++i;\n    return i;\n}\n```\n\n&emsp;&emsp;A. O(logn)\n\n&emsp;&emsp;B. O(n^½)\n\n&emsp;&emsp;C. O(n)\n\n&emsp;&emsp;D. O(nlogn)\n\n&emsp;&emsp;12. 设n是描述问题规模的非负整数，下列程序段的时间复杂度是（&emsp;）。\n\n```C\nx = 0;\nwhile (n >= (x + 1) * (x + 1))\nx = x + 1\n```\n\n&emsp;&emsp;A. O(logn)\n\n&emsp;&emsp;B. O(n^½)\n\n&emsp;&emsp;C. O(n) \n\n&emsp;&emsp;D. O(n²)\n\n&emsp;&emsp;13. 下列程序段的时间复杂度是（&emsp;）。\n\n```c\nint sum = 0;\nfor(int i = 1 ; i < n ;i *= 2)\n    for(int j = 0 ; j < i ; j++)\n        sum++;\n```\n\n&emsp;&emsp;A. O(logn)\n\n&emsp;&emsp;B. O(n) \n\n&emsp;&emsp;C. O(nlogn)\n\n&emsp;&emsp;D. O(n²)\n\n##### &emsp;&emsp;2.综合应用\n\n&emsp;&emsp;01. 一个算法所需时间由下述递归方程表示，试求出该算法的时间复杂度的级别（或阶）。\n$$\nT(n)=\\begin{cases}\n1    ,n = 1\\\\\n2T(n/2) + n,n>1\\\\\n\\end{cases}\n$$\n&emsp;&emsp;式中，n是问题的规模，为简单起见，设n是2的整数次幂。\n\n&emsp;&emsp;02. 分析以下各程序段，求出算法的时间复杂度。\n\n```C\n一、\ni = 1 ; k = 0\nwhile(i < n-1){\n    k = k + 10 * i;\n    i++;\n}\n二、 \ny = 0;\nwhile((y + 1) * (y + 1) <= n)\n    y = y + 1;\n三、\nfor(i = 1 ; i <= n ;i++)\n    for(j = 1 ; j <= i ;j++)\n        for(k = 1 ; k <= j ; k++)\n            x++;\n四、\nfor(i = 0 ; i < n ; i++)\n    for(j = 0 ; j < m; j++)\n        a[i][j] = 0;\n```\n\n\n\n#### &emsp;2.4测试答案\n\n##### &emsp;&emsp;1. 单项选择\n\n&emsp;&emsp;01. B\n\n&emsp;&emsp;程序不一定满足有穷性，如死循环、操作系统等，而算法必须有穷。算法代表对问题求解步骤的描述，而程序则是算法在计算机上的特定实现。C只是算法的必要条件，不能成为算法的定义。\n\n&emsp;&emsp;02. C\n\n&emsp;&emsp;时间复杂度为O(n²)，说明算法的时间复杂度T(n)满足T(n)≤cn²(c为比例常数)，即T(n) = O(n²)，时间复杂度T(n)是问题规模n的函数，其问题规模依然是n而不是n²。\n\n&emsp;&emsp;03. D\n\n&emsp;&emsp;找出基本运算i = i * 2，设执行次数为t，则2^t≤n，即t≤log₂n，因此时间复杂度T(n) = O(log₂n)。\n\n&emsp;&emsp;更直观的方法：计算基本运算i = i * 2的执行次数（每执行一次i乘2），其中判断条件可理解为2^t = n，即t = log₂n，则T(n) = O(log₂n)。\n\n&emsp;&emsp;04. C\n\n&emsp;&emsp;基本运算为i++，设执行次数为t，有t * t * t ≤ n，即t³≤n。所以T(n) = O(³√n)。\n\n&emsp;&emsp;05. D\n\n&emsp;&emsp;这是冒泡排序的算法代码，考查最坏情况下的元素交换次数。当所有相邻元素都为逆序时，则最后一行的语句依次都会执行。此时，\n$$\nT(n) = \\sum^{n-1}_{i=2}\\sum^{i-1}_{j=1}1=\\sum^{n-1}_{i=2}i-1=(n-2)(n-1)/2=O(n^2)\n$$\n&emsp;&emsp;06. A\n\n&emsp;&emsp;m++语句的执行次数为\n$$\n\\sum^{n}_{n=j}\\sum^{2i}_{j=1}1 = \\sum^{n}_{i=1}2i=n(n+1)\n$$\n&emsp;&emsp;07. A\n\n&emsp;&emsp;基本运算（执行频率最高的语句）为x = x * 2，每执行一次x * 2，设执行次数为t，则有2^(t+1)≤n/2，所以有\n$$\nt<log_2^{n/2}-1 = log_2^n-1\n$$\n可以得到T(n) = O(log₂n)。\n\n&emsp;&emsp;08. B\n\n&emsp;&emsp;递归出口为fact(1)，一共执行n次递归调用fact()，T(n) = O(n)。\n\n&emsp;&emsp;09. D\n\n&emsp;&emsp;两个升序链表合并，两两比较表中元素，每比较一次，确定一个元素的链接位置（取较小元素，头插法）。当一个链表比较结束后，将另一个链表的剩余元素插入即可。最坏的情况是两个链表中的元素依次进行比较，因为2max(m,n)≥m+n，所以时间复杂度O(max(m,n))。\n\n&emsp;&emsp;10. C\n\n&emsp;&emsp;内层循环条件j≤n与外层循环的变量无关，各自独立，每执行一次j自增1，每次内层循环都执行n次。外层循环条件k≤n，增量定义为 k*=2，可知循环次数k = 2^t ≤ n，即t ≤ log₂n。即内层循环的时间复杂度为O(n)，外层循环时间的时间复杂度为O(log₂n)。对于嵌套循环，根据乘法规则可知，该段程序的时间复杂度 T(n) = T₁(n) *  T₂(n) = O(nlog₂n)。\n\n&emsp;&emsp;11. B\n\n&emsp;&emsp;基本运算sum+=++i，它等价于++i；sum = sum + i；每执行一次i自增1。因此\n$$\nsum = 0 + 1 + 2 + …… + i = (1 + i) * i / 2\n$$\n可知循环次数t满足（1+t）* t/2 < n，因此时间复杂度为O(n½)。\n\n&emsp;&emsp;**注意，一般来说在计算时间复杂度和空间复杂度中log₂一般写为log，此时默认底数为2。**\n\n&emsp;&emsp;12. B\n\n&emsp;&emsp;假设第k次循环终止，则第k次执行时，(x+1)² > n ，x的初始值为0，第k次判断时，x = k-1，k > √k，因此，时间复杂度为O(√n)\n\n&emsp;&emsp;13. B\n\n&emsp;&emsp;当外层循环的变量 i 取不同值时，内层循环就执行多少次，因此总循环次数为 i 的所有取值之和。假设外层循环共执行k次，当 i = 1，2,4,8，……2^(k-1)时，内层循环执行 i 次，因此有总循环\n$$\nT = 1 + 2 +4 + 8 +……+ 2^{k-1} = 2^k - 1\n$$\n因此时间复杂度为O(n)。\n\n##### &emsp;&emsp;2. 综合应用\n\n&emsp;&emsp;01. 时间复杂度为O(nlog₂n)。\n\n&emsp;&emsp;设n = 2^k(k≥0)，由题有下述式子\n$$\nT(n^k) = 2T(2^{k-1}) + 2^k = 2^2T(2^{k-2})+2*2^k\n$$\n&emsp;&emsp;进而可以得到\n$$\nT(2^k) = 2^kT(2^0) + k*2^k\n$$\n&emsp;&emsp;即\n$$\nT(n) = 2^{log_2^n}+log_2^{n*n} = n(log_2n+1)\n$$\n&emsp;&emsp;也就是O(nlog₂n)。\n\n&emsp;&emsp;02. \n\n&emsp;&emsp;1. 基本语句 k = k +10 * i共执行了n-2次，所以T(n) = O(n)。\n\n&emsp;&emsp;2. 设循环体共执行了t次，每循环一次，循环变量y加1，最终t = y。故t²≤n，得T(n) = O(n½)。\n\n&emsp;&emsp;3. 基本语句x++的执行次数为\n$$\nT(n) = O(\\sum^n_{i=1}\\sum^i_{j=1}\\sum^j_{k=1}1) = O(\\frac{1}{6}n^3) =O(n^3)\n$$\n&emsp;&emsp;4. 内循环执行m次，外循环执行n次，根据乘法原理，共执行了m * n次，故T(m,n) = O(m * n)。\n\n\n\n\n\n### 三、归纳总结\n\n&emsp;&emsp;本章的重点是分析程序的时间复杂度。要掌握分析时间复杂度的方法和步骤。\n\n#### 1.循环主题中的变量参与循环条件的判断\n\n&emsp;&emsp;此类题应该找出主体语句中与T(n)成正比的循环变量，将之代入条件中进行计算。例如，\n\n```c\n1、\nint i = 1;\nwhile (i <= n)\n    i = i * 2;\n\n2、\nint y = 5;\nwhile ((y + 1) * (y + 1) < n)\n    y = y + 1;\n```\n\n&emsp;&emsp;例1中，i 乘以2的次数正是主体语句的执行次数t，因此有2^t≤n，取对数之后有t ≤ log₂n，则T(n) = O(log₂n)。\n\n&emsp;&emsp;例2中，y+1的次数恰好与T(n)成正比，记t为该程序的执行次数，并令t = y - 5，有y = t + 5，\n$$\n(t + 5 + 1)*(t + 5 + 1)<n\n$$\n得 t < √n - 6，即T(n) = O(√n)。\n\n\n\n#### 2.循环主体中变量与循环条件无关\n\n&emsp;&emsp;此类题可采用数学归纳法或直接累计循环次数。多层循环时，从内到外分析，忽略单步语句、条件判断语句，只关注主体语句的执行次数。此类问题又可分为递归程序和非递归程序：\n\n##### &emsp;2.1 递归程序\n\n&emsp;&emsp;一般使用公式进行递推。例如测试9的时间复杂度分析如下：\n$$\nT(n) = 1 + T(n - 1) = 1 + 1 +T(n-2)=……=n-1+T(1)\n$$\n&emsp;&emsp;即T(n) = O(n)\n\n##### &emsp;2.2非递归程序\n\n&emsp;&emsp;可以直接累计次数，例如测试11等。\n","tags":["数据结构"],"categories":["数据结构"]},{"title":"基于mediapipe的姿态识别和简单行为识别","url":"/2023/12/07/基于mediapipe的姿态识别和简单行为识别/","content":"&emsp;&emsp;本文是基于mediapipe的姿态识别和简单行为识别，通过对人体姿态关键点的坐标的使用，实现简单的举手检测，其行为检测的精度主要取决于mediapipe关键点的检测精度。\n<!--more-->\n\n## 一、mediapipe的安装\n\n&emsp;&emsp;以Pycharm为例，直接在终端里面输入指令\n\n> pip install  mediapipe\n\n&emsp;&emsp;等待下载完毕即可\n\n\n\n## 二、使用mediapipe检测关键点\n\n### 1.mediapipe的介绍\n\n   &emsp;&emsp;Mediapipe是一个用于构建机器学习管道的框架，用户处理视频、音频等时间序列数据。这个跨平台框架使用于桌面/服务器、Android、ios和各类嵌入式设备。\n\n   &emsp;&emsp;目前mediapipe包含以下16个solution，总的来说，mediapipe是一个很好的库，可以解决ML项目中面临的大部分麻烦，而且很适合做行为识别方向练手使用。\n\n   > 1.人脸检测\n   >\n   > 2.Face Mesh\n   >\n   > 3.虹膜\n   >\n   > 4.手\n   >\n   > 5.姿态\n   >\n   > 6.人体\n   >\n   > 7.人物分割\n   >\n   > 8.头发分割\n   >\n   > 9.目标检测\n   >\n   > 10.Box Tracking\n   >\n   > 11.instant Motion Tracking\n   >\n   > 12.3D目标检测\n   >\n   > 13.特征匹配\n   >\n   > 14.AutoFlip\n   >\n   > 15.MediaSequence\n   >\n   > 16.YouTuBe_8M\n\n### 2.使用mediapipe检测人体\n\n&emsp;&emsp;这里仅使用mediapipe关于人体识别的方法（solution），谷歌官方将这种人体姿态识别的方法叫做Blazepose。\n\n#### （1） 检测前的准备工作\n\n```python\n   '''导入一些基本的库'''\n   import cv2\n   import mediapipe as mp\n   import time\n   from tqdm import tqdm\n   import numpy as np\n   from PIL import Image, ImageFont, ImageDraw\n   # ------------------------------------------------\n   #   mediapipe的初始化\n   # \t这一步是必须的，因为要使用到以下定义的几个类\n   #   具体的函数参数意义可以参考第三方资料\n   # ------------------------------------------------\n   mp_pose = mp.solutions.pose\n   mp_drawing = mp.solutions.drawing_utils\n   pose = mp_pose.Pose(static_image_mode=True)\n   \n```\n\n#### （2）检测图片\n\n```python\n   def process_frame(img):\n       start_time = time.time()\n       h, w = img.shape[0], img.shape[1] # 高和宽\n       # 调整字体\n       tl = round(0.005 * (img.shape[0] + img.shape[1]) / 2) + 1\n       tf = max(tl-1, 1)\n       # BRG-->RGB\n       img_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n       # 将RGB图像输入模型，获取 关键点 预测结果\n       results = pose.process(img_RGB)\n       keypoints = ['' for i in range(33)]\n       if results.pose_landmarks:\n           mp_drawing.draw_landmarks(img, results.pose_landmarks, mp_pose.POSE_CONNECTIONS)\n           for i in range(33):\n               cx = int(results.pose_landmarks.landmark[i].x * w)\n               cy = int(results.pose_landmarks.landmark[i].y * h)\n               keypoints[i] = (cx, cy)\n               # 得到最终的33个关键点\n       else:\n           print(\"NO PERSON\")\n           struction = \"NO PERSON\"\n           img = cv2.putText(img, struction, (25, 100), cv2.FONT_HERSHEY_SIMPLEX, 1.25, (255, 255, 0),\n                             6)\n       end_time = time.time()\n       process_time = end_time - start_time\n       # 图片关键点预测时间\n       fps = 1 / process_time\n       # 帧率\n       colors = [[random.randint(0,255) for _ in range(3)] for _ in range(33)]\n       radius = [random.randint(8,15) for _ in range(33)]\n       for i in range(33):\n           cx, cy = keypoints[i]\n           #if i in range(33):\n           img = cv2.circle(img, (cx, cy), radius[i], colors[i], -1)\n       '''str_pose = get_pos(keypoints)#获取姿态\n       cv2.putText(img, \"POSE-{}\".format(str_pose), (12, 100), cv2.FONT_HERSHEY_TRIPLEX,\n                   tl / 3, (255, 0, 0), thickness=tf)'''\n       cv2.putText(img, \"FPS-{}\".format(str(int(fps))), (12, 100), cv2.FONT_HERSHEY_SIMPLEX,\n                   tl/3, (255, 255, 0),thickness=tf)\n       return img\n   \n```\n\n  &emsp;&emsp; 如果需要执行代码，则加入主函数使用\n\n```python\n   if __name__ == '__main__':\n   \timg0 = cv2.imread(\"./data/outImage--20.jpg\")\n       image = cv2.imdecode(np.fromfile(image_path, dtype=np.uint8), -1)\n       img = image.copy()\n       image = process_frame(img)\n       # 使用matplotlib画图    \n       fig, axes = plt.subplots(nrows=1, ncols=2)\n       axes[0].imshow(img0[:,:,::-1])\n       axes[0].set_title(\"原图\")\n       axes[1].imshow(image[:,:,::-1])\n       axes[1].set_title(\"检测并可视化后的图片\")\n       plt.rcParams[\"font.sans-serif\"] = ['SimHei']\n       plt.rcParams[\"axes.unicode_minus\"] = False\n       plt.show()\n       fig.savefig(\"./data/out.png\")\n   \n```\n\n#### （3）检测视频\n\n&emsp;&emsp;任何不涉及3D卷积的机器视觉方法，检测视频其实就是检测图片，因为视频是由多帧图片融合得来的。比如说一个30帧的视频，那么它的每一秒钟，就是由30张图片叠加而成。将这些分割出的图片分别进行检测，最后将检测的图片进行融合，得到的就是检测后的视频。有了这个依据，我们就可以把图片检测过程写成一个函数，在视频的每一帧中调用这个函数就可以了。\n\n&emsp;&emsp;一般使用OpenCV库将视频分解为图片帧的形式，示例代码如下：\n\n```python\ndef video2image(videoPath=\"./video/demo1.mp4\",\n                image_dir=\"./image\"):\n    '''videoPath是视频路径， image_dir是图片保存的文件夹路径'''\n    cap = cv2.VideoCapture(videoPath)\n    frame_count = 0\n    while(cap.isOpened()):\n        success,frame = cap.read()\n        if not success:\n            break\n        frame_count += 1\n    print(\"视频总帧数：\", frame_count)\n    cap.release()\n    cap = cv2.VideoCapture(videoPath)\n    count = 0\n    with tqdm(total=frame_count-1) as pbar:\n        try:\n            while(cap.isOpened()):\n                success, frame = cap.read()\n                if not success:\n                    break\n                #处理帧\n                try:\n                    if count % 20 == 0:\n                        cv2.imwrite(\"{}/outImage--{}.jpg\".format(image_dir, count), frame)\n                except:\n                    print(\"error\")\n                    pass\n                if success == True:\n                    pbar.update(1)\n                    count+=1\n        except:\n            print(\"中途中断\")\n            pass\n    cv2.destroyAllWindows()\n    cap.release()\n    print(\"视频已经处理结束，进行下一步操作！！！\")\n\n```\n\n&emsp;&emsp;那么落实到本文想要实现的功能上，就可以在视频分解出的帧后面加上图片检测函数。\n代码如下所示：\n\n```python\ndef process_video(video_path=\"./Data.mp4\"):\n    video_flag = False\n    cap = cv2.VideoCapture(video_path)\n    out_path = \"./out_Data.mp4\"\n    print(\"视频开始处理……\")\n    frame_count = 0\n    while (cap.isOpened()):\n        success, frame = cap.read()\n        frame_count += 1\n        if not success:\n            break\n    cap.release()\n    print(\"总帧数 = \", frame_count)\n    cap = cv2.VideoCapture(video_path)\n    if video_flag == False:\n        frame_size = cap.get(cv2.CAP_PROP_FRAME_WIDTH), cap.get(cv2.CAP_PROP_FRAME_HEIGHT)\n        #处理图像的尺寸。\n        fourcc = cv2.VideoWriter_fourcc(*'mp4v')\n        #保存视频文件的格式为mp4\n        fps = cap.get(cv2.CAP_PROP_FPS)\n        out = cv2.VideoWriter(out_path, fourcc, fps, (int(frame_size[0]),int(frame_size[1])), )\n        #输出图像的句柄\n    with tqdm(total=frame_count-1) as pbar:\n        try:\n            while cap.isOpened():\n                success, frame = cap.read()\n                if success:\n                    pbar.update(1)\n                    frame = process_frame(frame)\n                    # frame就是视频截取的帧，process_frame表示对其检测。\n                    cv2.namedWindow(\"frame\", cv2.WINDOW_NORMAL)\n                    cv2.imshow(\"frame\", frame)\n                    out.write(frame)\n                    if cv2.waitKey(1) == 27:\n                        break\n                else:\n                    break\n        except:\n            print(\"中途中断\")\n            pass\n    cap.release()\n    cv2.destroyAllWindows()\n    out.release()\n    print(\"视频已保存至\", out_path)\n\n```\n\n## 三、使用mediapipe-BlazePose检测自定义简单行为\n\n### 1.原理介绍\n\n&emsp;&emsp;将mediapipe用于行为检测是比较复杂的一件事；如果这样做，那么行为检测的精度完全取决于mediapipe关键点的检测精度，于是，可以根据下图中人的关节夹角来对人的姿势进行检测。\n\n<img src=\"人体关键点.jpg\" alt=\"人体关键点\" style=\"zoom:67%;\" />\n\n&emsp;&emsp;如举手的时候，手腕的15、16点应该是略高于0点，并且手臂于水平方向夹角一定是在80度到100度之间，那么这样就可以完成对举手动作的简单分类。\n\n### 2.实现过程\n\n&emsp;&emsp;首先要知道，由坐标求得矢量的公式，其实就是两个坐标相减。\n\n&emsp;&emsp;如已知三点P0(x0,y0)、P1(x1,y1)和P2(x2,y2)，那么求P0P1和P0P2两个矢量之间的夹角公式,用代码描写如下：\n\n```python\nv1 = (x1, y1) - (x2, y2)\nv2 = (x0, y0) - (x2, y2)\ndef get_angle(v1, v2):\n    angle = np.dot(v1, v2) / (np.sqrt(np.sum(v1 * v1)) * np.sqrt(np.sum(v2 * v2)))\n    angle = np.arccos(angle) / 3.14 * 180\n\n    cross = v2[0] * v1[1] - v2[1] * v1[0]\n    if cross < 0:\n        angle = - angle\n    return angle\n\n```\n\n&emsp;&emsp;这样就可以得到两个矢量的夹角。\n\n&emsp;&emsp;之后就可以通过夹角对行为进行判断，这里的规则是：\n\n```python\ndef get_pos(keypoints):\n    str_pose = \"\"\n    # 计算左臂与水平方向的夹角\n    keypoints = np.array(keypoints)\n    p_x_right, p_y_right = keypoints[16]\n    p_x_left, p_y_left = keypoints[15]\n    p_x_right_body, p_y_right_body = keypoints[11]\n    p_x_left_body, p_y_left_body = keypoints[12]\n\n    if p_y_right < p_y_right_body:\n        v1 = keypoints[14] - keypoints[16]\n        v2 = keypoints[12] - keypoints[11]\n        get_right_arm = abs(get_angle(v1, v2))\n        # print(\"R{}\".format(get_right_arm))\n        if 60 < get_right_arm < 120:\n            str_pose = \"RIGHT RAISE\"\n    elif p_y_left < p_y_left_body:\n        v1 = keypoints[13] - keypoints[15]\n        v2 = keypoints[11] - keypoints[12]\n        get_left_arm = abs(get_angle(v1, v2))\n        # print(\"L{}\".format(get_left_arm))\n        if 60 < get_left_arm < 120:\n            str_pose = \"LEFT RAISE\"\n    else:\n        str_pose = \"NO RAISE\"\n\n    return str_pose\n    \n```\n\n&emsp;&emsp;得到的str_pose就是行为字符串，在process_frame中可以得到可视化结果。\n\n## 四、总结和一些结果展示\n\n&emsp;&emsp;到这里，关键点检测与简单行为检测就已经全部结束了，这里是把基于tkinter的UI设计与mediapipe进行融合，实现可视化的交互过程，具体代码可以看[github](https://github.com/LiuHongjie1/-mediapipe-.git)。\n\n&emsp;&emsp;以下是一些样例 ~~感谢我的室友~~。\n\n\n\n<img src=\"no raise.jpg\" alt=\"no raise\" style=\"zoom:67%;\" />\n\n<img src=\"left raise.jpg\" alt=\"left raise\" style=\"zoom:67%;\" />\n\n<img src=\"right raise.jpg\" alt=\"right raise\" style=\"zoom:67%;\" />\n\n\n\n\n\n2023年12月15日修改：增加视频检测，修改部分代码\n\n2023年12月25日修改：修改可视化窗口，优化部分代码\n","tags":["Python","机器学习"],"categories":["机器学习"]},{"title":"空想家","url":"/2023/12/07/空想家/","content":"\n&emsp;&emsp;**学计算机一定要有一个非常强大的心理状态：计算机的所有东西都是人做出来的，别人能想出来的，我也一定能想得出来。**\n\n&emsp;&emsp;**在计算机里头，没有任何黑魔法。所有的东西，只不过是我现在不知道而已，总有一天，我会把所有的细节、所有的内部的东西，全都搞明白的。**\n\n"}]